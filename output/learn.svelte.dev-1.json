[
  {
    "title": "Component composition / Slot props • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/slot-props",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nTutorial\nSvelte\nSvelteKit\nPart 2\n/\nComponent composition\n/\nSlot props\n\nComponents can pass data back to their slotted content via slot props. In this app, we have a list of named CSS colours. Typing into the <input> will filter the list.\n\nRight now every row is showing AliceBlue, and as lovely a colour as it is, that's not what we want.\n\nOpen FilterableList.svelte. The <slot> is being rendered for each filtered item in the list. Pass the data into the slot:\n\nFilterableList.svelte\n<div class=\"content\">\n\t{#each data.filter(matches) as item}\n\t\t<slot {item} />\n\t{/each}\n</div>\n\n(As in other contexts, {item} is shorthand for item={item}.)\n\nThen, on the other side, expose the data to the slotted content with the let: directive:\n\nApp.svelte\n<FilterableList\n\tdata={colors}\n\tfield=\"name\"\n\tlet:item={row}\n>\n\t<div class=\"row\">\n\t\t<span class=\"color\" style=\"background-color: {row.hex}\" />\n\t\t<span class=\"name\">{row.name}</span>\n\t\t<span class=\"hex\">{row.hex}</span>\n\t\t<span class=\"rgb\">{row.rgb}</span>\n\t\t<span class=\"hsl\">{row.hsl}</span>\n\t</div>\n</FilterableList>\n\nFinally, get rid of the placeholder variable, which we no longer need:\n\nApp.svelte\n<script>\n\timport FilterableList from './FilterableList.svelte';\n\timport { colors } from './colors.js';\n\n\tlet row = colors[0];\n</script>\n\nNamed slots can also have props; use the let directive on an element with a slot=\"...\" attribute, instead of on the component itself.\n\nNext: Checking for slot content\n\nEdit this page\nsrc\nApp.svelte\nFilterableList.svelte\ncolors.js\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n<script>\n\timport FilterableList from './FilterableList.svelte';\n\timport { colors } from './colors.js';\n \n\tlet row = colors[0];\n</script>\n \n<FilterableList\n\tdata={colors}\n\tfield=\"name\"\n>\n\t<header slot=\"header\" class=\"row\">\n\t\t<span class=\"color\" />\n\t\t<span class=\"name\">name</span>\n\t\t<span class=\"hex\">hex</span>\n\t\t<span class=\"rgb\">rgb</span>\n\t\t<span class=\"hsl\">hsl</span>\n\t</header>\n \n\t<div class=\"row\">\n\t\t<span class=\"color\" style=\"background-color: {row.hex}\" />\n\t\t<span class=\"name\">{row.name}</span>\n\t\t<span class=\"hex\">{row.hex}</span>\n\t\t<span class=\"rgb\">{row.rgb}</span>\n\t\t<span class=\"hsl\">{row.hsl}</span>\n\t</div>\n</FilterableList>\n \n<style>\n\t.row {\n\t\tdisplay: grid;\n\t\talign-items: center;\n\t\tgrid-template-columns: 2em 4fr 3fr;\n\t\tgap: 1em;\n\t\tpadding: 0.1em;\n\t\tbackground: var(--bg-1);\n\t\tborder-radius: 0.2em;\n\t}\n \n\theader {\n\t\tfont-weight: bold;\n\t}\n \n\t.row:not(header):hover {\n\t\tbackground: var(--bg-2);\n\t}\n \n\t.color {\n\t\taspect-ratio: 1;\n\t\theight: 100%;\n\t\tborder-radius: 0.1em;\n\t}\n \n\t.rgb, .hsl {\n\t\tdisplay: none;\n\t}\n \n\t@media (min-width: 40rem) {\n\t\t.row {\n\t\t\tgrid-template-columns: 2em 4fr 3fr 3fr;\n\t\t}\n \n\t\t.rgb {\n\t\t\tdisplay: block;\n\t\t}\n\t}\n \n\t@media (min-width: 60rem) {\n\t\t.row {\n\t\t\tgrid-template-columns: 2em 4fr 3fr 3fr 3fr;\n\t\t}\n \n\t\t.hsl {\n\t\t\tdisplay: block;\n\t\t}\n\t}\n</style>\ninitialising"
  },
  {
    "title": "Component composition / Slot fallbacks • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/slot-fallbacks",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nTutorial\nSvelte\nSvelteKit\nPart 2\n/\nComponent composition\n/\nSlot fallbacks\n\nA component can specify fallbacks for any slots that are left empty, by putting content inside the <slot> element:\n\nCard.svelte\n<div class=\"card\">\n\t<header>\n\t\t<slot name=\"telephone\">\n\t\t\t<i>(telephone)</i>\n\t\t</slot>\n\t\t\n\t\t<slot name=\"company\">\n\t\t\t<i>(company name)</i>\n\t\t</slot>\n\t</header>\n\n\t<slot>\n\t\t<i>(name)</i>\n\t</slot>\n\t\t\n\t<footer>\n\t\t<slot name=\"address\">\n\t\t\t<i>(address)</i>\n\t\t</slot>\n\t</footer>\n</div>\n\nNext: Slot props\n\nEdit this page\nsrc\nApp.svelte\nCard.svelte\npaper.svg\nwood.svg\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n<script>\n\timport Card from './Card.svelte';\n</script>\n \n<main>\n\t<Card>\n\t\t<span>Patrick BATEMAN</span>\n\t\t<span>Vice President</span>\n \n\t\t<span slot=\"telephone\">212 555 6342</span>\n \n\t\t<span slot=\"company\">\n\t\t\tPierce &amp; Pierce\n\t\t\t<small>Mergers and Aquisitions</small>\n\t\t</span>\n\t\t\n\t\t<span slot=\"address\">358 Exchange Place, New York, N.Y. 100099 fax 212 555 6390 telex 10 4534</span>\n\t</Card>\n \n\t<Card />\n</main>\n \n<style>\n\tmain {\n\t\tdisplay: flex;\n\t\tflex-direction: column;\n\t\tjustify-content: center;\n\t\tgap: 2em;\n\t\tgrid-template-rows: 1fr 1fr;\n\t\tplace-items: center;\n\t\theight: 100%;\n\t\tbackground: url(./wood.svg);\n\t}\n \n\tsmall {\n\t\tdisplay: block;\n\t\tfont-size: 0.6em;\n\t\ttext-align: right;\n\t}\n \n\t@media (min-aspect-ratio: 3.5 / 2.0) {\n\t\tmain {\n\t\t\tflex-direction: row;\n\t\t}\n\t}\n</style>\ninitialising"
  },
  {
    "title": "Page options / ssr • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/ssr",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 4\n/\nPage options\n/\nssr\n\nServer-side rendering (SSR) is the process of generating HTML on the server, and is what SvelteKit does by default. It's important for performance and resilience, and is very beneficial for search engine optimization (SEO) — while some search engines can index content that is rendered in the browser with JavaScript, it happens less frequently and reliably.\n\nThat said, some components can't be rendered on the server, perhaps because they expect to be able to access browser globals like window immediately. If you can, you should change those components so that they can render on the server, but if you can't then you can disable SSR:\n\nsrc/routes/+page.server.js\nexport const ssr = false;\n\nSetting ssr to false inside your root +layout.server.js effectively turns your entire app into a single-page app (SPA).\n\nNext: csr\n\nEdit this page\nproject\nsrc\nroutes\n+page.svelte\napp.html\nstatic\nfavicon.png\npackage.json\nsvelte.config.js\nvite.config.js\nsolve \n1\n2\n<h1>{window.innerWidth}x{window.innerHeight}</h1>\n\n\ninitialising"
  },
  {
    "title": "Component composition / Checking for slot content • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/optional-slots",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nTutorial\nSvelte\nSvelteKit\nPart 2\n/\nComponent composition\n/\nChecking for slot content\n\nIn some cases, you may want to control parts of your component based on whether slotted content was passed in. For example, if we remove the <header> from App.svelte...\n\nApp.svelte\n<header slot=\"header\" class=\"row\">\n\t<span class=\"color\" />\n\t<span class=\"name\">name</span>\n\t<span class=\"hex\">hex</span>\n\t<span class=\"rgb\">rgb</span>\n\t<span class=\"hsl\">hsl</span>\n</header>\n\n<div class=\"row\">\n\t<span class=\"color\" style=\"background-color: {row.hex}\" />\n\t<span class=\"name\">{row.name}</span>\n\t<span class=\"hex\">{row.hex}</span>\n\t<span class=\"rgb\">{row.rgb}</span>\n\t<span class=\"hsl\">{row.hsl}</span>\n</div>\n\n...we're left with an ugly double border because FilterableList.svelte is still rendering the <div class=\"header\">.\n\nWe can fix that by using the special $$slots variable in FilterableList.svelte:\n\nFilterableList.svelte\n{#if $$slots.header}\n\t<div class=\"header\">\n\t\t<slot name=\"header\"/>\n\t</div>\n{/if}\n\nNext: Context API\n\nEdit this page\nsrc\nApp.svelte\nFilterableList.svelte\ncolors.js\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n<script>\n\timport FilterableList from './FilterableList.svelte';\n\timport { colors } from './colors.js';\n</script>\n \n<FilterableList\n\tdata={colors}\n\tfield=\"name\"\n\tlet:item={row}\n>\n\t<header slot=\"header\" class=\"row\">\n\t\t<span class=\"color\" />\n\t\t<span class=\"name\">name</span>\n\t\t<span class=\"hex\">hex</span>\n\t\t<span class=\"rgb\">rgb</span>\n\t\t<span class=\"hsl\">hsl</span>\n\t</header>\n \n\t<div class=\"row\">\n\t\t<span class=\"color\" style=\"background-color: {row.hex}\" />\n\t\t<span class=\"name\">{row.name}</span>\n\t\t<span class=\"hex\">{row.hex}</span>\n\t\t<span class=\"rgb\">{row.rgb}</span>\n\t\t<span class=\"hsl\">{row.hsl}</span>\n\t</div>\n</FilterableList>\n \n<style>\n\t.row {\n\t\tdisplay: grid;\n\t\talign-items: center;\n\t\tgrid-template-columns: 2em 4fr 3fr;\n\t\tgap: 1em;\n\t\tpadding: 0.1em;\n\t\tbackground: var(--bg-1);\n\t\tborder-radius: 0.2em;\n\t}\n \n\theader {\n\t\tfont-weight: bold;\n\t}\n \n\t.row:not(header):hover {\n\t\tbackground: var(--bg-2);\n\t}\n \n\t.row:hover {\n\t\tbackground: var(--bg-2);\n\t}\n \n\t.color {\n\t\taspect-ratio: 1;\n\t\theight: 100%;\n\t\tborder-radius: 0.1em;\n\t}\n \n\t.rgb, .hsl {\n\t\tdisplay: none;\n\t}\n \n\t@media (min-width: 40rem) {\n\t\t.row {\n\t\t\tgrid-template-columns: 2em 4fr 3fr 3fr;\n\t\t}\n \n\t\t.rgb {\n\t\t\tdisplay: block;\n\t\t}\n\t}\n \n\t@media (min-width: 60rem) {\n\t\t.row {\n\t\t\tgrid-template-columns: 2em 4fr 3fr 3fr 3fr;\n\t\t}\n \n\t\t.hsl {\n\t\t\tdisplay: block;\n\t\t}\n\t}\n</style>\ninitialising"
  },
  {
    "title": "Component composition / Named slots • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/named-slots",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nTutorial\nSvelte\nSvelteKit\nPart 2\n/\nComponent composition\n/\nNamed slots\n\nThe previous example contained a default slot, which renders the direct children of a component. Sometimes you will need more control over placement. In those cases, we can use named slots.\n\nInside App.svelte, we're rendering a <Card> component that contains <span slot=\"telephone\"> and others for company and address. Let's add the corresponding named slots in Card.svelte:\n\nCard.svelte\n<div class=\"card\">\n\t<header>\n\t\t<slot name=\"telephone\" />\n\t\t<slot name=\"company\" />\n\t</header>\n\n\t<slot />\n\t\t\n\t<footer>\n\t\t<slot name=\"address\" />\n\t</footer>\n</div>\n\nWe need to add some styles to the <small> element in App.svelte so that it occupies its own line. The contents of <Card> inherit styles from Card.svelte, such as font-family (the lettering is something called 'Silian Rail'), but normal scoping rules apply — we need to add the styles to App.svelte because that's where the element is:\n\nApp.svelte\n<style>\n\tmain {\n\t\tdisplay: grid;\n\t\tplace-items: center;\n\t\theight: 100%;\n\t\tbackground: url(./wood.svg);\n\t}\n\n\tsmall {\n\t\tdisplay: block;\n\t\tfont-size: 0.6em;\n\t\ttext-align: right;\n\t}\n</style>\n\nAlternatively, we could use the :global modifier inside Card.svelte to target all small elements inside .card:\n\nCard.svelte\n<style>\n\t/* ... */ \n\n\t.card :global(small) {\n\t\tdisplay: block;\n\t\tfont-size: 0.6em;\n\t\ttext-align: right;\n\t}\n</style>\n\nNext: Slot fallbacks\n\nEdit this page\nsrc\nApp.svelte\nCard.svelte\npaper.svg\nwood.svg\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n<script>\n\timport Card from './Card.svelte';\n</script>\n \n<main>\n\t<Card>\n\t\t<span>Patrick BATEMAN</span>\n\t\t<span>Vice President</span>\n \n\t\t<span slot=\"telephone\">212 555 6342</span>\n \n\t\t<span slot=\"company\">\n\t\t\tPierce &amp; Pierce\n\t\t\t<small>Mergers and Aquisitions</small>\n\t\t</span>\n\t\t\n\t\t<span slot=\"address\">358 Exchange Place, New York, N.Y. 100099 fax 212 555 6390 telex 10 4534</span>\n\t</Card>\n</main>\n \n<style>\n\tmain {\n\t\tdisplay: grid;\n\t\tplace-items: center;\n\t\theight: 100%;\n\t\tbackground: url(./wood.svg);\n\t}\n</style>\ninitialising"
  },
  {
    "title": "Conclusion / Next steps • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/next-steps",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nTutorial\nSvelte\nSvelteKit\nPart 4\n/\nConclusion\n/\nNext steps\n\nCongratulations! If you've made it the entire way through this tutorial, you can now consider yourself a Svelte and SvelteKit expert.\n\nYou can start building apps on your own machine with the create-svelte package:\n\nnpm create svelte@latest\n\nSvelte and SvelteKit will continue to evolve, and so will this tutorial. Check back periodically for updates.\n\nTo keep up with developments in the Svelte world, join our Discord server at svelte.dev/chat and follow Svelte Society on Twitter. We're so happy to welcome you to the Svelte community!\n\nEdit this page\nproject\nsrc\nroutes\n+page.svelte\napp.html\nstatic\nfavicon.png\npackage.json\nsvelte.config.js\nvite.config.js\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n<span>the end</span>\n \n<style>\n\tspan {\n\t\twidth: 100%;\n\t\theight: 100%;\n\t\tdisplay: flex;\n\t\tjustify-content: center;\n\t\talign-items: center;\n\t\tfont-size: 4em;\n\t}\n</style>\ninitialising"
  },
  {
    "title": "Context API / setContext and getContext • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/context-api",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nTutorial\nSvelte\nSvelteKit\nPart 2\n/\nContext API\n/\nsetContext and getContext\n\nThe context API provides a mechanism for components to 'talk' to each other without passing around data and functions as props, or dispatching lots of events. It's an advanced feature, but a useful one. In this exercise, we're going to recreate Schotter by George Nees — one of the pioneers of generative art — using the context API.\n\nInside Canvas.svelte, there's an addItem function that adds an item to the canvas. We can make it available to components inside <Canvas>, like <Square>, with setContext:\n\nCanvas.svelte\n<script>\n\timport { setContext, afterUpdate, onMount, tick } from 'svelte';\n\n\t// ...\n\n\tonMount(() => {\n\t\tctx = canvas.getContext('2d');\n\t});\n\n\tsetContext('canvas', {\n\t\taddItem\n\t});\n\n\tfunction addItem(fn) {...}\n\n\tfunction draw() {...}\n</script>\n\nInside child components, we can now get the context with, well, getContext:\n\nSquare.svelte\n<script>\n\timport { getContext } from 'svelte';\n\n\texport let x;\n\texport let y;\n\texport let size;\n\texport let rotate;\n\n\tgetContext('canvas').addItem(draw);\n\n\tfunction draw(ctx) {...}\n</script>\n\nSo far, so... boring. Let's add some randomness to the grid:\n\nApp.svelte\n<div class=\"container\">\n\t<Canvas width={800} height={1200}>\n\t\t{#each Array(12) as _, c}\n\t\t\t{#each Array(22) as _, r}\n\t\t\t\t<Square\n\t\t\t\t\tx={180 + c * 40 + jitter(r * 2)}\n\t\t\t\t\ty={180 + r * 40 + jitter(r * 2)}\n\t\t\t\t\tsize={40}\n\t\t\t\t\trotate={jitter(r * 0.05)}\n\t\t\t\t/>\n\t\t\t{/each}\n\t\t{/each}\n\t</Canvas>\n</div>\n\nLike lifecycle functions, setContext and getContext must be called during component initialisation. (The context key ('canvas' in this case) can be anything you like, including non-strings, which is useful for controlling who can access the context.)\n\nYour context object can include anything, including stores. This allows you to pass values that change over time to child components:\n\n// in a parent component\nimport { setContext } from 'svelte';\nimport { writable } from 'svelte/store';\n\nsetContext('my-context', {\n\tcount: writable(0)\n});\n// in a child component\nimport { getContext } from 'svelte';\n\nconst { count } = getContext('my-context');\n\n$: console.log({ count: $count });\n\nNext: Special elements\n\nEdit this page\nsrc\nApp.svelte\nCanvas.svelte\nSquare.svelte\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n<script>\n\timport Canvas from './Canvas.svelte';\n\timport Square from './Square.svelte';\n \n\t// we use a seeded random number generator to get consistent jitter\n\tlet seed = 1;\n \n\tfunction random() {\n\t\tseed *= 16807;\n\t\tseed %= 2147483647;\n\t\treturn (seed - 1) / 2147483646;\n\t}\n \n\tfunction jitter(amount) {\n\t\treturn amount * (random() - 0.5);\n\t}\n</script>\n \n<div class=\"container\">\n\t<Canvas width={800} height={1200}>\n\t\t{#each Array(12) as _, c}\n\t\t\t{#each Array(22) as _, r}\n\t\t\t\t<Square\n\t\t\t\t\tx={180 + c * 40}\n\t\t\t\t\ty={180 + r * 40}\n\t\t\t\t\tsize={40}\n\t\t\t\t/>\n\t\t\t{/each}\n\t\t{/each}\n\t</Canvas>\n</div>\n \n<style>\n\t.container {\n\t\theight: 100%;\n\t\taspect-ratio: 2 / 3;\n\t\tmargin: 0 auto;\n\t\tbackground: rgb(224, 219, 213);\n\t\tfilter: drop-shadow(0.5em 0.5em 1em rgba(0, 0, 0, 0.1));\n\t}\n</style>\ninitialising"
  },
  {
    "title": "Environment variables / $env/dynamic/public • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/env-dynamic-public",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nTutorial\nSvelte\nSvelteKit\nPart 4\n/\nEnvironment variables\n/\n$env/dynamic/public\n\nAs with private environment variables, it's preferable to use static values if possible, but if necessary we can use dynamic values instead:\n\nsrc/routes/+page.svelte\n<script>\n\timport { env } from '$env/dynamic/public';\n</script>\n\n<main\n\tstyle:background={env.PUBLIC_THEME_BACKGROUND}\n\tstyle:color={env.PUBLIC_THEME_FOREGROUND}\n>\n\t{env.PUBLIC_THEME_FOREGROUND} on {env.PUBLIC_THEME_BACKGROUND}\n</main>\n\nNext: Conclusion\n\nEdit this page\nproject\nsrc\nroutes\n+page.svelte\napp.html\nstatic\nfavicon.png\n.env\npackage.json\nsvelte.config.js\nvite.config.js\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n<script>\n\timport {\n\t\tPUBLIC_THEME_BACKGROUND,\n\t\tPUBLIC_THEME_FOREGROUND\n\t} from '$env/static/public';\n</script>\n \n<main\n\tstyle:background={PUBLIC_THEME_BACKGROUND}\n\tstyle:color={PUBLIC_THEME_FOREGROUND}\n>\n\t{PUBLIC_THEME_FOREGROUND} on {PUBLIC_THEME_BACKGROUND}\n</main>\n \n<style>\n\tmain {\n\t\tposition: fixed;\n\t\tdisplay: flex;\n\t\talign-items: center;\n\t\tjustify-content: center;\n\t\tleft: 0;\n\t\ttop: 0;\n\t\twidth: 100%;\n\t\theight: 100%;\n\t\tfont-size: 10vmin;\n\t}\n</style>\n \ninitialising"
  },
  {
    "title": "Component composition / Slots • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/slots",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nTutorial\nSvelte\nSvelteKit\nPart 2\n/\nComponent composition\n/\nSlots\n\nJust like elements can have children...\n\n<div>\n\t<p>I'm a child of the div</p>\n</div>\n\n...so can components. Before a component can accept children, though, it needs to know where to put them. We do this with the <slot> element. Put this inside Card.svelte:\n\nCard.svelte\n<div class=\"card\">\n\t<slot />\n</div>\n\nYou can now put things on the card:\n\nApp.svelte\n<Card>\n\t<span>Patrick BATEMAN</span>\n\t<span>Vice President</span>\n</Card>\n\nNext: Named slots\n\nEdit this page\nsrc\nApp.svelte\nCard.svelte\npaper.svg\nwood.svg\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n<script>\n\timport Card from './Card.svelte';\n</script>\n \n<main>\n\t<Card>\n\t\t<!-- content goes here -->\n\t</Card>\n</main>\n \n<style>\n\tmain {\n\t\tdisplay: grid;\n\t\tplace-items: center;\n\t\theight: 100%;\n\t\tbackground: url(./wood.svg);\n\t}\n</style>\ninitialising"
  },
  {
    "title": "Special elements / <svelte:self> • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/svelte-self",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nTutorial\nSvelte\nSvelteKit\nPart 2\n/\nSpecial elements\n/\n<svelte:self>\n\nSvelte provides a variety of built-in elements. The first, <svelte:self>, allows a component to contain itself recursively.\n\nIt's useful for things like this folder tree view, where folders can contain other folders. In Folder.svelte we want to be able to do this...\n\nFolder.svelte\n{#if file.files}\n\t<Folder {...file}/>\n{:else}\n\t<File {...file}/>\n{/if}\n\n...but that's impossible, because a module can't import itself. Instead, we use <svelte:self>:\n\nFolder.svelte\n{#if file.files}\n\t<svelte:self {...file}/>\n{:else}\n\t<File {...file}/>\n{/if}\n\nNext: <svelte:component>\n\nEdit this page\nsrc\nApp.svelte\nFile.svelte\nFolder.svelte\ndata.js\nsolve \n1\n2\n3\n4\n5\n6\n7\n<script>\n\timport Folder from './Folder.svelte';\n\timport { files } from './data.js';\n</script>\n \n<Folder name=\"Home\" {files} expanded />\n \ninitialising"
  },
  {
    "title": "Environment variables / $env/static/public • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/env-static-public",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nTutorial\nSvelte\nSvelteKit\nPart 4\n/\nEnvironment variables\n/\n$env/static/public\n\nSome environment variables can be safely exposed to the browser. These are distinguished from private environment variables with a PUBLIC_ prefix.\n\nAdd values to the two public environment variables in .env:\n\n.env\nPUBLIC_THEME_BACKGROUND=\"steelblue\"\nPUBLIC_THEME_FOREGROUND=\"bisque\"\n\nThen, import them into src/routes/+page.svelte:\n\nsrc/routes/+page.svelte\n<script>\n\tconst PUBLIC_THEME_BACKGROUND = 'white';\n\tconst PUBLIC_THEME_FOREGROUND = 'black';\n\timport {\n\t\tPUBLIC_THEME_BACKGROUND,\n\t\tPUBLIC_THEME_FOREGROUND\n\t} from '$env/static/public';\n</script>\n\nNext: $env/dynamic/public\n\nEdit this page\nproject\nsrc\nroutes\n+page.svelte\napp.html\nstatic\nfavicon.png\n.env\npackage.json\nsvelte.config.js\nvite.config.js\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n<script>\n\tconst PUBLIC_THEME_BACKGROUND = 'white';\n\tconst PUBLIC_THEME_FOREGROUND = 'black';\n</script>\n \n<main\n\tstyle:background={PUBLIC_THEME_BACKGROUND}\n\tstyle:color={PUBLIC_THEME_FOREGROUND}\n>\n\t{PUBLIC_THEME_FOREGROUND} on {PUBLIC_THEME_BACKGROUND}\n</main>\n \n<style>\n\tmain {\n\t\tposition: fixed;\n\t\tdisplay: flex;\n\t\talign-items: center;\n\t\tjustify-content: center;\n\t\tleft: 0;\n\t\ttop: 0;\n\t\twidth: 100%;\n\t\theight: 100%;\n\t\tfont-size: 10vmin;\n\t}\n</style>\n \ninitialising"
  },
  {
    "title": "Classes and styles / Component styles • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/component-styles",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nTutorial\nSvelte\nSvelteKit\nPart 2\n/\nClasses and styles\n/\nComponent styles\n\nOften, you need to influence the styles inside a child component. Perhaps we want to make these boxes red, green and blue.\n\nOne way to do this is with the :global CSS modifier, which allows you to indiscriminately target elements inside other components:\n\nApp.svelte\n<style>\n\t.boxes :global(.box:nth-child(1)) {\n\t\tbackground-color: red;\n\t}\n\n\t.boxes :global(.box:nth-child(2)) {\n\t\tbackground-color: green;\n\t}\n\n\t.boxes :global(.box:nth-child(3)) {\n\t\tbackground-color: blue;\n\t}\n</style>\n\nBut there are lots of reasons not to do that. For one thing, it's extremely verbose. For another, it's brittle — any changes to the implementation details of Box.svelte could break the selector.\n\nMost of all though, it's rude. Components should be able to decide for themselves which styles can be controlled from 'outside', in the same way they decide which variables are exposed as props. :global should be used as an escape hatch — a last resort.\n\nInside Box.svelte, change background-color so that it is determined by a CSS custom property:\n\nBox.svelte\n<style>\n\t.box {\n\t\twidth: 5em;\n\t\theight: 5em;\n\t\tborder-radius: 0.5em;\n\t\tmargin: 0 0 1em 0;\n\t\tbackground-color: var(--color, #ddd);\n\t}\n</style>\n\nAny parent element (such as <div class=\"boxes\">) can set the value of --color, but we can also set it on individual components:\n\nApp.svelte\n<div class=\"boxes\">\n\t<Box --color=\"red\" />\n\t<Box --color=\"green\" />\n\t<Box --color=\"blue\" />\n</div>\n\nThe values can be dynamic, like any other attribute.\n\nThis feature works by wrapping each component in a <div style=\"display: contents\">, where needed, and applying the custom properties to it.\n\nNext: Component composition\n\nEdit this page\nsrc\nApp.svelte\nBox.svelte\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n<script>\n\timport Box from './Box.svelte';\n</script>\n \n<div class=\"boxes\">\n\t<Box />\n\t<Box />\n\t<Box />\n</div>\ninitialising"
  },
  {
    "title": "Special elements / <svelte:component> • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/svelte-component",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nTutorial\nSvelte\nSvelteKit\nPart 2\n/\nSpecial elements\n/\n<svelte:component>\n\nA component can change its type altogether with <svelte:component>. In this exercise, we want to show RedThing.svelte if the color is red, GreenThing.svelte if it's green, and so on.\n\nWe could do this with a sequence of if blocks...\n\nApp.svelte\n{#if selected.color === 'red'}\n\t<RedThing/>\n{:else if selected.color === 'green'}\n\t<GreenThing/>\n{:else if selected.color === 'blue'}\n\t<BlueThing/>\n{/if}\n\n...but it's a little cumbersome. Instead, we can create a single dynamic component:\n\nApp.svelte\n<select bind:value={selected}>\n\t{#each options as option}\n\t\t<option value={option}>{option.color}</option>\n\t{/each}\n</select>\n\n<svelte:component this={selected.component} />\n\nThe this value can be any component constructor, or a falsy value — if it's falsy, no component is rendered.\n\nNext: <svelte:element>\n\nEdit this page\nsrc\nApp.svelte\nBlueThing.svelte\nGreenThing.svelte\nRedThing.svelte\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n<script>\n\timport RedThing from './RedThing.svelte';\n\timport GreenThing from './GreenThing.svelte';\n\timport BlueThing from './BlueThing.svelte';\n \n\tconst options = [\n\t\t{ color: 'red', component: RedThing },\n\t\t{ color: 'green', component: GreenThing },\n\t\t{ color: 'blue', component: BlueThing }\n\t];\n \n\tlet selected = options[0];\n</script>\n \n<select bind:value={selected}>\n\t{#each options as option}\n\t\t<option value={option}>{option.color}</option>\n\t{/each}\n</select>\n \n{#if selected.color === 'red'}\n\t<RedThing />\n{:else}\n\t<p>TODO others</p>\n{/if}\n \ninitialising"
  },
  {
    "title": "Environment variables / $env/dynamic/private • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/env-dynamic-private",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nTutorial\nSvelte\nSvelteKit\nPart 4\n/\nEnvironment variables\n/\n$env/dynamic/private\n\nIf you need to read the values of environment variables when the app runs, as opposed to when the app is built, you can use $env/dynamic/private instead of $env/static/private:\n\nsrc/routes/+page.server.js\nimport { redirect, fail } from '@sveltejs/kit';\nimport { env } from '$env/dynamic/private';\n\nexport function load({ cookies }) {\n\tif (cookies.get('allowed')) {\n\t\tthrow redirect(307, '/welcome');\n\t}\n}\n\nexport const actions = {\n\tdefault: async ({ request, cookies }) => {\n\t\tconst data = await request.formData();\n\n\t\tif (data.get('passphrase') === env.PASSPHRASE) {\n\t\t\tcookies.set('allowed', 'true', {\n\t\t\t\tpath: '/'\n\t\t\t});\n\n\t\t\tthrow redirect(303, '/welcome');\n\t\t}\n\n\t\treturn fail(403, {\n\t\t\tincorrect: true\n\t\t});\n\t}\n};\n\n\nNext: $env/static/public\n\nEdit this page\nproject\nsrc\nroutes\nwelcome\n+page.server.js\n+page.svelte\n+page.server.js\n+page.svelte\napp.html\nstatic\nfavicon.png\n.env\npackage.json\nsvelte.config.js\nvite.config.js\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n<script>\n\texport let form;\n</script>\n \n<form method=\"POST\">\n\t<label>\n\t\tenter the passphrase\n\t\t<input name=\"passphrase\" autocomplete=\"off\" />\n\t</label>\n</form>\n \n{#if form?.incorrect}\n\t<p class=\"error\">wrong passphrase!</p>\n{/if}\n \n<style>\n\t.error {\n\t\tcolor: red;\n\t}\n</style>\n \ninitialising"
  },
  {
    "title": "Classes and styles / The style directive • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/styles",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nTutorial\nSvelte\nSvelteKit\nPart 2\n/\nClasses and styles\n/\nThe style directive\n\nAs with class, you can write your inline style attributes literally, because Svelte is really just HTML with fancy bits:\n\nApp.svelte\n<button\n\tclass=\"card\"\n\tstyle=\"transform: {flipped ? 'rotateY(0)' : ''}; --bg-1: palegoldenrod; --bg-2: black; --bg-3: goldenrod\"\n\ton:click={() => flipped = !flipped}\n>\n\nWhen you have a lot of styles, it can start to look a bit wacky. We can tidy things up by using the style: directive:\n\nApp.svelte\n<button\n\tclass=\"card\"\n\tstyle:transform={flipped ? 'rotateY(0)' : ''}\n\tstyle:--bg-1=\"palegoldenrod\"\n\tstyle:--bg-2=\"black\"\n\tstyle:--bg-3=\"goldenrod\"\n\ton:click={() => flipped = !flipped}\n>\n\nNext: Component styles\n\nEdit this page\nsrc\nApp.svelte\nsvelte-logo.svg\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n<script>\n\tlet flipped = false;\n</script>\n \n<div class=\"container\">\n\tFlip the card\n\t<button\n\t\tclass=\"card\"\n\t\tclass:flipped\n\t\ton:click={() => flipped = !flipped}\n\t>\n\t\t<div class=\"front\">\n\t\t\t<span class=\"symbol\">♠</span>\n\t\t</div>\n\t\t<div class=\"back\">\n\t\t\t<div class=\"pattern\"></div>\n\t\t</div>\n\t</button>\n</div>\n \n<style>\n\t.container {\n\t\tdisplay: flex;\n\t\tflex-direction: column;\n\t\tgap: 1em;\n\t\theight: 100%;\n\t\talign-items: center;\n\t\tjustify-content: center;\n\t\tperspective: 100vh;\n\t}\n \n\t.card {\n\t\tposition: relative;\n\t\taspect-ratio: 2.5 / 3.5;\n\t\tfont-size: min(1vh, 0.25rem);\n\t\theight: 80em;\n\t\tbackground: var(--bg-1);\n\t\tborder-radius: 2em;\n\t\ttransform: rotateY(180deg);\n\t\ttransition: transform 0.4s;\n\t\ttransform-style: preserve-3d;\n\t\tpadding: 0;\n\t\tuser-select: none;\n\t\tcursor: pointer;\n\t}\n \n\t.card.flipped {\n\t\ttransform: rotateY(0);\n\t}\n \n\t.front, .back {\n\t\tdisplay: flex;\n\t\talign-items: center;\n\t\tjustify-content: center;\n\t\tposition: absolute;\n\t\twidth: 100%;\n\t\theight: 100%;\n\t\tleft: 0;\n\t\ttop: 0;\n\t\tbackface-visibility: hidden;\n\t\tborder-radius: 2em;\n\t\tborder: 1px solid var(--fg-2);\n\t\tbox-sizing: border-box;\n\t\tpadding: 2em;\n\t}\n \n\t.front {\n\t\tbackground: url(./svelte-logo.svg) no-repeat 5em 5em, url(./svelte-logo.svg) no-repeat calc(100% - 5em) calc(100% - 5em);\n\t\tbackground-size: 8em 8em, 8em 8em;\n\t}\n \n\t.back {\n\t\ttransform: rotateY(180deg);\n\t}\n \n\t.symbol {\n\t\tfont-size: 30em;\n\t\tcolor: var(--fg-1);\n\t}\n \n\t.pattern {\n\t\twidth: 100%;\n\t\theight: 100%;\n\t\tbackground-color: var(--bg-2);\n\t\t/* pattern from https://projects.verou.me/css3patterns/#marrakesh */\n\t\tbackground-image:\n\t\tradial-gradient(var(--bg-3) 0.9em, transparent 1em),\n\t\trepeating-radial-gradient(var(--bg-3) 0, var(--bg-3) 0.4em, transparent 0.5em, transparent 2em, var(--bg-3) 2.1em, var(--bg-3) 2.5em, transparent 2.6em, transparent 5em);\n\t\tbackground-size: 3em 3em, 9em 9em;\n\t\tbackground-position: 0 0;\n\t\tborder-radius: 1em;\n\t}\n</style>\n \ninitialising"
  },
  {
    "title": "Special elements / <svelte:element> • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/svelte-element",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nTutorial\nSvelte\nSvelteKit\nPart 2\n/\nSpecial elements\n/\n<svelte:element>\n\nSimilarly, we don't always know in advance what kind of DOM element to render. <svelte:element> comes in handy here. As with the previous exercise, we can replace a long sequence of if blocks with a single dynamic element:\n\nApp.svelte\n<select bind:value={selected}>\n\t{#each options as option}\n\t\t<option value={option}>{option}</option>\n\t{/each}\n</select>\n\n<svelte:element this={selected}>\n\tI'm a <code>&lt;{selected}&gt;</code> element\n</svelte:element>\n\nThe this value can be any string, or a falsy value — if it's falsy, no element is rendered.\n\nNext: <svelte:window>\n\nEdit this page\nsrc\nApp.svelte\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n<script>\n\tconst options = ['h1', 'h2', 'h3', 'p', 'marquee'];\n\tlet selected = options[0];\n</script>\n \n<select bind:value={selected}>\n\t{#each options as option}\n\t\t<option value={option}>{option}</option>\n\t{/each}\n</select>\n \n{#if selected === 'h1'}\n\t<h1>I'm a <code>&lt;h1&gt;</code> element</h1>\n{:else}\n\t<p>TODO others</p>\n{/if}\n \ninitialising"
  },
  {
    "title": "Environment variables / $env/static/private • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/env-static-private",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nTutorial\nSvelte\nSvelteKit\nPart 4\n/\nEnvironment variables\n/\n$env/static/private\n\nEnvironment variables — like API keys and database credentials — can be added to a .env file, and they will be made available to your application.\n\nYou can also use .env.local or .env.[mode] files — see the Vite documentation for more information. Make sure you add any files containing sensitive information to your .gitignore file!\n\nEnvironment variables in process.env are also available via $env/static/private.\n\nIn this exercise, we want to allow the user to enter the website if they know the correct passphrase, using an environment variable.\n\nFirst, in .env, add a new environment variable:\n\n.env\nPASSPHRASE=\"open sesame\"\n\nOpen src/routes/+page.server.js. Import PASSPHRASE from $env/static/private and use it inside the form action:\n\nsrc/routes/+page.server.js\nimport { redirect, fail } from '@sveltejs/kit';\nimport { PASSPHRASE } from '$env/static/private';\n\nexport function load({ cookies }) {\n\tif (cookies.get('allowed')) {\n\t\tthrow redirect(307, '/welcome');\n\t}\n}\n\nexport const actions = {\n\tdefault: async ({ request, cookies }) => {\n\t\tconst data = await request.formData();\n\n\t\tif (data.get('passphrase') === PASSPHRASE) {\n\t\t\tcookies.set('allowed', 'true', {\n\t\t\t\tpath: '/'\n\t\t\t});\n\n\t\t\tthrow redirect(303, '/welcome');\n\t\t}\n\n\t\treturn fail(403, {\n\t\t\tincorrect: true\n\t\t});\n\t}\n};\n\nThe website is now accessible to anyone who knows the correct passphrase.\n\nKeeping secrets\n\nIt's important that sensitive data doesn't accidentally end up being sent to the browser, where it could easily be stolen by hackers and scoundrels.\n\nSvelteKit makes it easy to prevent this from happening. Notice what happens if we try to import PASSPHRASE into src/routes/+page.svelte:\n\nsrc/routes/+page.svelte\n<script>\n\timport { PASSPHRASE } from '$env/static/private';\n\texport let form;\n</script>\n\nAn error overlay pops up, telling us that $env/static/private cannot be imported into client-side code. It can only be imported into server modules:\n\n+page.server.js\n+layout.server.js\n+server.js\nany modules ending with .server.js\nany modules inside src/lib/server\n\nIn turn, these modules can only be imported by other server modules.\n\nStatic vs dynamic\n\nThe static in $env/static/private indicates that these values are known at build time, and can be statically replaced. This enables useful optimisations:\n\nimport { FEATURE_FLAG_X } from '$env/static/private';\n\nif (FEATURE_FLAG_X === 'enabled') {\n\t// code in here will be removed from the build output\n\t// if FEATURE_FLAG_X is not enabled\n}\n\nIn some cases you might need to refer to environment variables that are dynamic — in other words, not known until we run the app. We'll cover this case in the next exercise.\n\nNext: $env/dynamic/private\n\nEdit this page\nproject\nsrc\nroutes\nwelcome\n+page.server.js\n+page.svelte\n+page.server.js\n+page.svelte\napp.html\nstatic\nfavicon.png\n.env\npackage.json\nsvelte.config.js\nvite.config.js\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n<script>\n\texport let form;\n</script>\n \n<form method=\"POST\">\n\t<label>\n\t\tenter the passphrase\n\t\t<input name=\"passphrase\" autocomplete=\"off\" />\n\t</label>\n</form>\n \n{#if form?.incorrect}\n\t<p class=\"error\">wrong passphrase!</p>\n{/if}\n \n<style>\n\t.error {\n\t\tcolor: red;\n\t}\n</style>\n \ninitialising"
  },
  {
    "title": "Classes and styles / Shorthand class directive • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/class-shorthand",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nTutorial\nSvelte\nSvelteKit\nPart 2\n/\nClasses and styles\n/\nShorthand class directive\n\nOften, the name of the class will be the same as the name of the value it depends on:\n\n<button\n\tclass=\"card\"\n\tclass:flipped={flipped}\n\ton:click={() => flipped = !flipped}\n>\n\nIn those cases we can use a shorthand form:\n\nApp.svelte\n<button\n\tclass=\"card\"\n\tclass:flipped\n\ton:click={() => flipped = !flipped}\n>\n\nNext: The style directive\n\nEdit this page\nsrc\nApp.svelte\nsvelte-logo.svg\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n<script>\n\tlet flipped = false;\n</script>\n \n<div class=\"container\">\n\tFlip the card\n\t<button\n\t\tclass=\"card\"\n\t\tclass:flipped={flipped}\n\t\ton:click={() => flipped = !flipped}\n\t>\n\t\t<div class=\"front\">\n\t\t\t<span class=\"symbol\">♠</span>\n\t\t</div>\n\t\t<div class=\"back\">\n\t\t\t<div class=\"pattern\"></div>\n\t\t</div>\n\t</button>\n</div>\n \n<style>\n\t.container {\n\t\tdisplay: flex;\n\t\tflex-direction: column;\n\t\tgap: 1em;\n\t\theight: 100%;\n\t\talign-items: center;\n\t\tjustify-content: center;\n\t\tperspective: 100vh;\n\t}\n \n\t.card {\n\t\tposition: relative;\n\t\taspect-ratio: 2.5 / 3.5;\n\t\tfont-size: min(1vh, 0.25rem);\n\t\theight: 80em;\n\t\tbackground: var(--bg-1);\n\t\tborder-radius: 2em;\n\t\ttransform: rotateY(180deg);\n\t\ttransition: transform 0.4s;\n\t\ttransform-style: preserve-3d;\n\t\tpadding: 0;\n\t\tuser-select: none;\n\t\tcursor: pointer;\n\t}\n \n\t.card.flipped {\n\t\ttransform: rotateY(0);\n\t}\n \n\t.front, .back {\n\t\tdisplay: flex;\n\t\talign-items: center;\n\t\tjustify-content: center;\n\t\tposition: absolute;\n\t\twidth: 100%;\n\t\theight: 100%;\n\t\tleft: 0;\n\t\ttop: 0;\n\t\tbackface-visibility: hidden;\n\t\tborder-radius: 2em;\n\t\tborder: 1px solid var(--fg-2);\n\t\tbox-sizing: border-box;\n\t\tpadding: 2em;\n\t}\n \n\t.front {\n\t\tbackground: url(./svelte-logo.svg) no-repeat 5em 5em, url(./svelte-logo.svg) no-repeat calc(100% - 5em) calc(100% - 5em);\n\t\tbackground-size: 8em 8em, 8em 8em;\n\t}\n \n\t.back {\n\t\ttransform: rotateY(180deg);\n\t}\n \n\t.symbol {\n\t\tfont-size: 30em;\n\t\tcolor: var(--fg-1);\n\t}\n \n\t.pattern {\n\t\twidth: 100%;\n\t\theight: 100%;\n\t\tbackground-color: var(--bg-2);\n\t\t/* pattern from https://projects.verou.me/css3patterns/#marrakesh */\n\t\tbackground-image:\n\t\tradial-gradient(var(--bg-3) 0.9em, transparent 1em),\n\t\trepeating-radial-gradient(var(--bg-3) 0, var(--bg-3) 0.4em, transparent 0.5em, transparent 2em, var(--bg-3) 2.1em, var(--bg-3) 2.5em, transparent 2.6em, transparent 5em);\n\t\tbackground-size: 3em 3em, 9em 9em;\n\t\tbackground-position: 0 0;\n\t\tborder-radius: 1em;\n\t}\n</style>\n \ninitialising"
  },
  {
    "title": "Special elements / <svelte:window> • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/svelte-window",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nTutorial\nSvelte\nSvelteKit\nPart 2\n/\nSpecial elements\n/\n<svelte:window>\n\nJust as you can add event listeners to any DOM element, you can add event listeners to the window object with <svelte:window>.\n\nWe've already got a handleKeydown function declared — now all we need to do is add a keydown listener:\n\nApp.svelte\n<svelte:window on:keydown={handleKeydown} />\n\nAs with DOM elements, you can add event modifiers like preventDefault.\n\nNext: <svelte:window> bindings\n\nEdit this page\nsrc\nApp.svelte\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n<script>\n\tlet key;\n\tlet keyCode;\n \n\tfunction handleKeydown(event) {\n\t\tkey = event.key;\n\t\tkeyCode = event.keyCode;\n\t}\n</script>\n \n<svelte:window />\n \n<div style=\"text-align: center\">\n\t{#if key}\n\t\t<kbd>{key === ' ' ? 'Space' : key}</kbd>\n\t\t<p>{keyCode}</p>\n\t{:else}\n\t\t<p>Focus this window and press any key</p>\n\t{/if}\n</div>\n \n<style>\n\tdiv {\n\t\tdisplay: flex;\n\t\theight: 100%;\n\t\talign-items: center;\n\t\tjustify-content: center;\n\t\tflex-direction: column;\n\t}\n \n\tkbd {\n\t\tborder-radius: 4px;\n\t\tfont-size: 6em;\n\t\tpadding: 0.2em 0.5em;\n\t\tbackground-color: #eeeeee;\n\t\tborder-top: 5px solid #f9f9f9;\n\t\tborder-left: 5px solid #f9f9f9;\n\t\tborder-right: 5px solid #aaaaaa;\n\t\tborder-bottom: 5px solid #aaaaaa;\n\t\tcolor: #555;\n\t}\n</style>\n \ninitialising"
  },
  {
    "title": "Bindings / Checkbox inputs • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/checkbox-inputs",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nTutorial\nSvelte\nSvelteKit\nPart 1\n/\nBindings\n/\nCheckbox inputs\n\nCheckboxes are used for toggling between states. Instead of binding to input.value, we bind to input.checked:\n\nApp.svelte\n<input type=\"checkbox\" bind:checked={yes}>\n\nNext: Select bindings\n\nEdit this page\nsrc\nApp.svelte\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n<script>\n\tlet yes = false;\n</script>\n \n<label>\n\t<input type=\"checkbox\" checked={yes} />\n\tYes! Send me regular email spam\n</label>\n \n{#if yes}\n\t<p>\n\t\tThank you. We will bombard your inbox and sell\n\t\tyour personal details.\n\t</p>\n{:else}\n\t<p>\n\t\tYou must opt in to continue. If you're not\n\t\tpaying, you're the product.\n\t</p>\n{/if}\n \n<button disabled={!yes}>Subscribe</button>\n \ninitialising"
  },
  {
    "title": "Bindings / Select bindings • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/select-bindings",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 1\n/\nBindings\n/\nSelect bindings\n\nWe can also use bind:value with <select> elements:\n\nApp.svelte\n<select\n\tbind:value={selected}\n\ton:change={() => answer = ''}\n>\n\nNote that the <option> values are objects rather than strings. Svelte doesn't mind.\n\nBecause we haven't set an initial value of selected, the binding will set it to the default value (the first in the list) automatically. Be careful though — until the binding is initialised, selected remains undefined, so we can't blindly reference e.g. selected.id in the template.\n\nNext: Group inputs\n\nEdit this page\nsrc\nApp.svelte\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n<script>\n\tlet questions = [\n\t\t{\n\t\t\tid: 1,\n\t\t\ttext: `Where did you go to school?`\n\t\t},\n\t\t{\n\t\t\tid: 2,\n\t\t\ttext: `What is your mother's name?`\n\t\t},\n\t\t{\n\t\t\tid: 3,\n\t\t\ttext: `What is another personal fact that an attacker could easily find with Google?`\n\t\t}\n\t];\n\n\n\tlet selected;\n\n\n\tlet answer = '';\n\n\n\tfunction handleSubmit() {\n\t\talert(\n\t\t\t`answered question ${selected.id} (${selected.text}) with \"${answer}\"`\n\t\t);\n\t}\n</script>\n\n\n<h2>Insecurity questions</h2>\n\n\n<form on:submit|preventDefault={handleSubmit}>\n\t<select\n\t\tvalue={selected}\n\t\ton:change={() => (answer = '')}\n\t>\n\t\t{#each questions as question}\n\t\t\t<option value={question}>\ninitialising"
  },
  {
    "title": "Bindings / Numeric inputs • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/numeric-inputs",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 1\n/\nBindings\n/\nNumeric inputs\n\nIn the DOM, everything is a string. That's unhelpful when you're dealing with numeric inputs — type=\"number\" and type=\"range\" — as it means you have to remember to coerce input.value before using it.\n\nWith bind:value, Svelte takes care of it for you:\n\nApp.svelte\n<label>\n\t<input type=\"number\" bind:value={a} min=\"0\" max=\"10\" />\n\t<input type=\"range\" bind:value={a} min=\"0\" max=\"10\" />\n</label>\n\n<label>\n\t<input type=\"number\" bind:value={b} min=\"0\" max=\"10\" />\n\t<input type=\"range\" bind:value={b} min=\"0\" max=\"10\" />\n</label>\n\nNext: Checkbox inputs\n\nEdit this page\nsrc\nApp.svelte\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n⌄\n⌄\n⌄\n<script>\n\tlet a = 1;\n\tlet b = 2;\n</script>\n\n\n<label>\n\t<input type=\"number\" value={a} min=\"0\" max=\"10\" />\n\t<input type=\"range\" value={a} min=\"0\" max=\"10\" />\n</label>\n\n\n<label>\n\t<input type=\"number\" value={b} min=\"0\" max=\"10\" />\n\t<input type=\"range\" value={b} min=\"0\" max=\"10\" />\n</label>\n\n\n<p>{a} + {b} = {a + b}</p>\n\n\nbooting webcontainer"
  },
  {
    "title": "Animations / The animate directive • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/animate",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 2\n/\nAnimations\n/\nThe animate directive\n\nIn the previous chapter, we used deferred transitions to create the illusion of motion as elements move from one todo list to the other.\n\nTo complete the illusion, we also need to apply motion to the elements that aren't transitioning. For this, we use the animate directive.\n\nFirst, import the flip function — flip stands for 'First, Last, Invert, Play' — from svelte/animate into TodoList.svelte:\n\nTodoList.svelte\n<script>\n\timport { flip } from 'svelte/animate';\n\timport { send, receive } from './transition.js';\n\n\texport let store;\n\texport let done;\n</script>\n\nThen add it to the <li> elements:\n\nTodoList.svelte\n<li\n\tclass:done\n\tin:receive={{ key: todo.id }}\n\tout:send={{ key: todo.id }}\n\tanimate:flip\n>\n\nThe movement is a little slow in this case, so we can add a duration parameter:\n\nTodoList.svelte\n<li\n\tclass:done\n\tin:receive={{ key: todo.id }}\n\tout:send={{ key: todo.id }}\n\tanimate:flip={{ duration: 200 }}\n>\n\nduration can also be a d => milliseconds function, where d is the number of pixels the element has to travel\n\nNote that all the transitions and animations are being applied with CSS, rather than JavaScript, meaning they won't block (or be blocked by) the main thread.\n\nNext: Actions\n\nEdit this page\nsrc\nApp.svelte\nTodoList.svelte\nremove.svg\ntodos.js\ntransition.js\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n<script>\n\timport { send, receive } from './transition.js';\n\n\n\texport let store;\n\texport let done;\n</script>\n\n\n<ul class=\"todos\">\n\t{#each $store.filter((todo) => todo.done === done) as todo (todo.id)}\n\t\t<li\n\t\t\tclass:done\n\t\t\tin:receive={{ key: todo.id }}\n\t\t\tout:send={{ key: todo.id }}\n\t\t>\n\t\t\t<label>\n\t\t\t\t<input\n\t\t\t\t\ttype=\"checkbox\"\n\t\t\t\t\tchecked={todo.done}\n\t\t\t\t\ton:change={(e) => store.mark(todo, e.currentTarget.checked)}\n\t\t\t\t/>\n\n\n\t\t\t\t<span>{todo.description}</span>\n\n\n\t\t\t\t<button on:click={() => store.remove(todo)} aria-label=\"Remove\" />\n\t\t\t</label>\n\t\t</li>\n\t{/each}\n</ul>\n\n\n<style>\n\tlabel {\n\t\twidth: 100%;\n\t\theight: 100%;\n\t\tdisplay: flex;\n\t}\n\n\nbooting webcontainer"
  },
  {
    "title": "Advanced loading / invalidateAll • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/invalidate-all",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 4\n/\nAdvanced loading\n/\ninvalidateAll\n\nFinally, there's the nuclear option — invalidateAll(). This will indiscriminately re-run all load functions for the current page, regardless of what they depend on.\n\nUpdate src/routes/[...timezone]/+page.svelte from the previous exercise:\n\nsrc/routes/[...timezone]/+page.svelte\n<script>\n\timport { onMount } from 'svelte';\n\timport { invalidateAll } from '$app/navigation';\n\n\texport let data;\n\n\tonMount(() => {\n\t\tconst interval = setInterval(() => {\n\t\t\tinvalidateAll();\n\t\t}, 1000);\n\n\t\treturn () => {\n\t\t\tclearInterval(interval);\n\t\t};\n\t});\n</script>\n\nThe depends call in src/routes/+layout.js is no longer necessary:\n\nsrc/routes/+layout.js\nexport async function load({ depends }) {\n\tdepends('data:now');\n\n\treturn {\n\t\tnow: Date.now()\n\t};\n}\n\ninvalidate(() => true) and invalidateAll are not the same. invalidateAll also re-runs load functions without any url dependencies, which invalidate(() => true) does not.\n\nNext: Environment variables\n\nEdit this page\nproject\nsrc\nroutes\n[...timezone]\n+page.js\n+page.svelte\napi\nnow\n+server.js\n+layout.js\n+layout.svelte\n+page.svelte\napp.html\nstatic\nfavicon.png\npackage.json\nsvelte.config.js\nvite.config.js\nsolve \n1\n\n\nbooting webcontainer"
  },
  {
    "title": "Special elements / <svelte:window> bindings • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/svelte-window-bindings",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 2\n/\nSpecial elements\n/\n<svelte:window> bindings\n\nWe can also bind to certain properties of window, such as scrollY:\n\nApp.svelte\n<svelte:window bind:scrollY={y} />\n\nThe list of properties you can bind to is as follows:\n\ninnerWidth\ninnerHeight\nouterWidth\nouterHeight\nscrollX\nscrollY\nonline — an alias for window.navigator.onLine\n\nAll except scrollX and scrollY are readonly.\n\nNext: <svelte:body>\n\nEdit this page\nsrc\nApp.svelte\ndeepsea.webp\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n⌄\n⌄\n⌄\n⌄\n<script>\n\tlet y = 0;\n</script>\n\n\n<svelte:window />\n\n\n<span>depth: {y}px</span>\n\n\n<style>\n\t:global(body) {\n\t\theight: 400vw;\n\t\tbackground: url(./deepsea.webp);\n\t\tbackground-size: cover;\n\t}\n\n\n\tspan {\n\t\tposition: fixed;\n\t\tfont-size: 2em;\n\t\tcolor: white;\n\t\tfont-variant: tabular-nums;\n\t}\n</style>\ninitialising"
  },
  {
    "title": "Classes and styles / The class directive • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/classes",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 2\n/\nClasses and styles\n/\nThe class directive\n\nLike any other attribute, you can specify classes with a JavaScript attribute. Here, we could add a flipped class to the card:\n\nApp.svelte\n<button\n\tclass=\"card {flipped ? 'flipped' : ''}\"\n\ton:click={() => flipped = !flipped}\n>\n\nThis works as expected — if you click on the card now, it'll flip.\n\nWe can make it nicer though. Adding or removing a class based on some condition is such a common pattern in UI development that Svelte includes a special directive to simplify it:\n\nApp.svelte\n<button\n\tclass=\"card\"\n\tclass:flipped={flipped}\n\ton:click={() => flipped = !flipped}\n>\n\nThis directive means 'add the flipped class whenever flipped is truthy'.\n\nNext: Shorthand class directive\n\nEdit this page\nsrc\nApp.svelte\nsvelte-logo.svg\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n<script>\n\tlet flipped = false;\n</script>\n\n\n<div class=\"container\">\n\tFlip the card\n\t<button\n\t\tclass=\"card\"\n\t\ton:click={() => flipped = !flipped}\n\t>\n\t\t<div class=\"front\">\n\t\t\t<span class=\"symbol\">♠</span>\n\t\t</div>\n\t\t<div class=\"back\">\n\t\t\t<div class=\"pattern\"></div>\n\t\t</div>\n\t</button>\n</div>\n\n\n<style>\n\t.container {\n\t\tdisplay: flex;\n\t\tflex-direction: column;\n\t\tgap: 1em;\n\t\theight: 100%;\n\t\talign-items: center;\n\t\tjustify-content: center;\n\t\tperspective: 100vh;\n\t}\n\n\n\t.card {\n\t\tposition: relative;\n\t\taspect-ratio: 2.5 / 3.5;\n\t\tfont-size: min(1vh, 0.25rem);\n\t\theight: 80em;\n\t\tbackground: var(--bg-1);\ninitialising"
  },
  {
    "title": "Transitions / Deferred transitions • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/deferred-transitions",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 2\n/\nTransitions\n/\nDeferred transitions\n\nA particularly powerful feature of Svelte's transition engine is the ability to defer transitions, so that they can be coordinated between multiple elements.\n\nTake this pair of todo lists, in which toggling a todo sends it to the opposite list. In the real world, objects don't behave like that — instead of disappearing and reappearing in another place, they move through a series of intermediate positions. Using motion can go a long way towards helping users understand what's happening in your app.\n\nWe can achieve this effect using the crossfade function, as seen in transition.js, which creates a pair of transitions called send and receive. When an element is 'sent', it looks for a corresponding element being 'received', and generates a transition that transforms the element to its counterpart's position and fades it out. When an element is 'received', the reverse happens. If there is no counterpart, the fallback transition is used.\n\nOpen TodoList.svelte. First, import the send and receive transitions from transition.js:\n\nTodoList.svelte\n<script>\n\timport { send, receive } from './transition.js';\n\n\texport let store;\n\texport let done;\n</script>\n\nThen, add them to the <li> element, using the todo.id property as a key to match the elements:\n\nTodoList.svelte\n<li\n\tclass:done\n\tin:receive={{ key: todo.id }}\n\tout:send={{ key: todo.id }}\n>\n\nNow, when you toggle items, they move smoothly to their new location. The non-transitioning items still jump around awkwardly — we can fix that in the next chapter.\n\nNext: Animations\n\nEdit this page\nsrc\nApp.svelte\nTodoList.svelte\nremove.svg\ntodos.js\ntransition.js\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n⌄\n⌄\n⌄\n⌄\n⌄\n<script>\n\timport { createTodoStore } from './todos.js';\n\timport TodoList from './TodoList.svelte';\n\n\n\tconst todos = createTodoStore([\n\t\t{ done: false, description: 'write some docs' },\n\t\t{ done: false, description: 'start writing blog post' },\n\t\t{ done: true, description: 'buy some milk' },\n\t\t{ done: false, description: 'mow the lawn' },\n\t\t{ done: false, description: 'feed the turtle' },\n\t\t{ done: false, description: 'fix some bugs' }\n\t]);\n</script>\n\n\n<div class=\"board\">\n\t<input\n\t\tplaceholder=\"what needs to be done?\"\n\t\ton:keydown={(e) => {\n\t\t\tif (e.key !== 'Enter') return;\n\n\n\t\t\ttodos.add(e.currentTarget.value);\n\t\t\te.currentTarget.value = '';\n\t\t}}\n\t/>\n\n\n\t<div class=\"todo\">\n\t\t<h2>todo</h2>\n\t\t<TodoList store={todos} done={false} />\n\t</div>\n\n\n\t<div class=\"done\">\n\t\t<h2>done</h2>\n\t\t<TodoList store={todos} done={true} />\n\t</div>\n</div>\n\n\ninitialising"
  },
  {
    "title": "Bindings / Group inputs • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/group-inputs",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 1\n/\nBindings\n/\nGroup inputs\n\nIf you have multiple type=\"radio\" or type=\"checkbox\" inputs relating to the same value, you can use bind:group along with the value attribute. Radio inputs in the same group are mutually exclusive; checkbox inputs in the same group form an array of selected values.\n\nAdd bind:group={scoops} to the radio inputs...\n\nApp.svelte\n<input\n\ttype=\"radio\"\n\tname=\"scoops\"\n\tvalue={number}\n\tbind:group={scoops}\n/>\n\n...and bind:group={flavours} to the checkbox inputs:\n\nApp.svelte\n<input\n\ttype=\"checkbox\"\n\tname=\"flavours\"\n\tvalue={flavour}\n\tbind:group={flavours}\n/>\n\nNext: Select multiple\n\nEdit this page\nsrc\nApp.svelte\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n<script>\n\tlet scoops = 1;\n\tlet flavours = [];\n\n\n\tconst formatter = new Intl.ListFormat('en', { style: 'long', type: 'conjunction' });\n</script>\n\n\n<h2>Size</h2>\n\n\n{#each [1, 2, 3] as number}\n\t<label>\n\t\t<input\n\t\t\ttype=\"radio\"\n\t\t\tname=\"scoops\"\n\t\t\tvalue={number}\n\t\t/>\n\n\n\t\t{number} {number === 1 ? 'scoop' : 'scoops'}\n\t</label>\n{/each}\n\n\n<h2>Flavours</h2>\n\n\n{#each ['cookies and cream', 'mint choc chip', 'raspberry ripple'] as flavour}\n\t<label>\n\t\t<input\n\t\t\ttype=\"checkbox\"\n\t\t\tname=\"flavours\"\n\t\t\tvalue={flavour}\n\t\t/>\n\n\n\t\t{flavour}\n\t</label>\n{/each}\n\n\n{#if flavours.length === 0}\ninitialising"
  },
  {
    "title": "Bindings / Text inputs • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/text-inputs",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 1\n/\nBindings\n/\nText inputs\n\nAs a general rule, data flow in Svelte is top down — a parent component can set props on a child component, and a component can set attributes on an element, but not the other way around.\n\nSometimes it's useful to break that rule. Take the case of the <input> element in this component — we could add an on:input event handler that sets the value of name to event.target.value, but it's a bit... boilerplatey. It gets even worse with other form elements, as we'll see.\n\nInstead, we can use the bind:value directive:\n\nApp.svelte\n<input bind:value={name}>\n\nThis means that not only will changes to the value of name update the input value, but changes to the input value will update name.\n\nNext: Numeric inputs\n\nEdit this page\nsrc\nApp.svelte\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n⌄\n<script>\n\tlet name = 'world';\n</script>\n\n\n<input value={name} />\n\n\n<h1>Hello {name}!</h1>\n\n\ninitialising"
  },
  {
    "title": "Logic / If blocks • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/if-blocks",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 1\n/\nLogic\n/\nIf blocks\n\nHTML doesn't have a way of expressing logic, like conditionals and loops. Svelte does.\n\nTo conditionally render some markup, we wrap it in an if block. Let's add some text that appears when count is greater than 10:\n\nApp.svelte\n<button on:click={increment}>\n\tClicked {count}\n\t{count === 1 ? 'time' : 'times'}\n</button>\n\n{#if count > 10}\n\t<p>{count} is greater than 10</p>\n{/if}\n\nTry it — update the component, and click on the button.\n\nNext: Else blocks\n\nEdit this page\nsrc\nApp.svelte\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n⌄\n⌄\n⌄\n<script>\n\tlet count = 0;\n\n\n\tfunction increment() {\n\t\tcount += 1;\n\t}\n</script>\n\n\n<button on:click={increment}>\n\tClicked {count}\n\t{count === 1 ? 'time' : 'times'}\n</button>\n\n\ninitialising"
  },
  {
    "title": "Actions / The use directive • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/actions",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 2\n/\nActions\n/\nThe use directive\n\nActions are essentially element-level lifecycle functions. They're useful for things like:\n\ninterfacing with third-party libraries\nlazy-loaded images\ntooltips\nadding custom event handlers\n\nIn this app, you can scribble on the <canvas>, and change colours and brush size via the menu. But if you open the menu and cycle through the options with the Tab key, you'll soon find that the focus isn't trapped inside the modal.\n\nWe can fix that with an action. Import trapFocus from actions.js...\n\nApp.svelte\n<script>\n\timport Canvas from './Canvas.svelte';\n\timport { trapFocus } from './actions.js';\n\n\tconst colors = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet', 'white', 'black'];\n\tlet selected = colors[0];\n\tlet size = 10;\n\n\tlet showMenu = true;\n</script>\n\n...then add it to the menu with the use: directive:\n\nApp.svelte\n<div class=\"menu\" use:trapFocus>\n\nLet's take a look at the trapFocus function in actions.js. An action function is called with a node — the <div class=\"menu\"> in our case — when the node is mounted to the DOM, and can return an action object with a destroy method.\n\nFirst, we need to add an event listener that intercepts Tab key presses:\n\nactions.js\nfocusable()[0]?.focus();\n\nnode.addEventListener('keydown', handleKeydown);\n\nSecond, we need to do some cleanup when the node is unmounted — removing the event listener, and restoring focus to where it was before the element mounted:\n\nactions.js\nfocusable()[0]?.focus();\n\nnode.addEventListener('keydown', handleKeydown);\n\nreturn {\n\tdestroy() {\n\t\tnode.removeEventListener('keydown', handleKeydown);\n\t\tprevious?.focus();\n\t}\n};\n\nNow, when you open the menu, you can cycle through the options with the Tab key.\n\nNext: Adding parameters\n\nEdit this page\nsrc\nApp.svelte\nCanvas.svelte\nactions.js\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n<script>\n\timport Canvas from './Canvas.svelte';\n\n\n\tconst colors = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet', 'white', 'black'];\n\tlet selected = colors[0];\n\tlet size = 10;\n\n\n\tlet showMenu = true;\n</script>\n\n\n<div class=\"container\">\n\t<Canvas color={selected} size={size} />\n\n\n\t{#if showMenu}\n\t\t<div\n\t\t\tclass=\"modal-background\"\n\t\t\ton:click|self={() => showMenu = false}\n\t\t\ton:keydown={(e) => {\n\t\t\t\tif (e.key === 'Escape') showMenu = false;\n\t\t\t}}\n\t\t>\n\t\t\t<div class=\"menu\">\n\t\t\t\t<div class=\"colors\">\n\t\t\t\t\t{#each colors as color}\n\t\t\t\t\t\t<button\n\t\t\t\t\t\t\tclass=\"color\"\n\t\t\t\t\t\t\taria-label={color}\n\t\t\t\t\t\t\taria-current={selected === color}\n\t\t\t\t\t\t\tstyle=\"--color: {color}\"\n\t\t\t\t\t\t\ton:click={() => {\n\t\t\t\t\t\t\t\tselected = color;\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t/>\n\t\t\t\t\t{/each}\n\t\t\t\t</div>\n\n\ninitialising"
  },
  {
    "title": "Advanced bindings / Binding to component instances • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/component-this",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 2\n/\nAdvanced bindings\n/\nBinding to component instances\n\nJust as you can bind to DOM elements, you can bind to component instances themselves with bind:this.\n\nThis is useful in the rare cases that you need to interact with a component programmatically (rather than by providing it with updated props). Revisiting our canvas app from a few exercises ago, it would be nice to add a button to clear the screen.\n\nFirst, let's export a function from Canvas.svelte:\n\nCanvas.svelte\nexport let color;\nexport let size;\n\nexport function clear() {\n\tcontext.clearRect(0, 0, canvas.width, canvas.height);\n}\n\nThen, create a reference to the component instance:\n\nApp.svelte\n<script>\n\timport Canvas from './Canvas.svelte';\n\timport { trapFocus } from './actions.js';\n\n\tconst colors = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet', 'white', 'black'];\n\tlet selected = colors[0];\n\tlet size = 10;\n\n\tlet showMenu = true;\n\tlet canvas;\n</script>\n\n<div class=\"container\">\n\t<Canvas bind:this={canvas} color={selected} size={size} />\n\nFinally, add a button that calls the clear function:\n\nApp.svelte\n<div class=\"controls\">\n\t<button class=\"show-menu\" on:click={() => showMenu = !showMenu}>\n\t\t{showMenu ? 'close' : 'menu'}\n\t</button>\n\n\t<button on:click={() => canvas.clear()}>\n\t\tclear\n\t</button>\n</div>\n\nNext: Classes and styles\n\nEdit this page\nsrc\nApp.svelte\nCanvas.svelte\nactions.js\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n<script>\n\timport Canvas from './Canvas.svelte';\n\timport { trapFocus } from './actions.js';\n\n\n\tconst colors = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet', 'white', 'black'];\n\tlet selected = colors[0];\n\tlet size = 10;\n\n\n\tlet showMenu = true;\n</script>\n\n\n<div class=\"container\">\n\t<Canvas color={selected} size={size} />\n\n\n\t{#if showMenu}\n\t\t<div\n\t\t\tclass=\"modal-background\"\n\t\t\ton:click|self={() => showMenu = false}\n\t\t\ton:keydown={(e) => {\n\t\t\t\tif (e.key === 'Escape') showMenu = false;\n\t\t\t}}\n\t\t>\n\t\t\t<div class=\"menu\" use:trapFocus>\n\t\t\t\t<div class=\"colors\">\n\t\t\t\t\t{#each colors as color}\n\t\t\t\t\t\t<button\n\t\t\t\t\t\t\tclass=\"color\"\n\t\t\t\t\t\t\taria-label={color}\n\t\t\t\t\t\t\taria-current={selected === color}\n\t\t\t\t\t\t\tstyle=\"--color: {color}\"\n\t\t\t\t\t\t\ton:click={() => {\n\t\t\t\t\t\t\t\tselected = color;\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t/>\n\t\t\t\t\t{/each}\n\t\t\t\t</div>\ninitialising"
  },
  {
    "title": "Advanced loading / Custom dependencies • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/custom-dependencies",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nTutorial\nSvelte\nSvelteKit\nPart 4\n/\nAdvanced loading\n/\nCustom dependencies\n\nCalling fetch(url) inside a load function registers url as a dependency. Sometimes it's not appropriate to use fetch, in which case you can specify a dependency manually with the depends(url) function.\n\nSince any string that begins with an [a-z]+: pattern is a valid URL, we can create custom invalidation keys like data:now.\n\nUpdate src/routes/+layout.js to return a value directly rather than making a fetch call, and add the depends:\n\nsrc/routes/+layout.js\nexport async function load({ depends }) {\n\tdepends('data:now');\n\n\treturn {\n\t\tnow: Date.now()\n\t};\n}\n\nNow, update the invalidate call in src/routes/[...timezone]/+page.svelte:\n\nsrc/routes/[...timezone]/+page.svelte\n<script>\n\timport { onMount } from 'svelte';\n\timport { invalidate } from '$app/navigation';\n\n\texport let data;\n\n\tonMount(() => {\n\t\tconst interval = setInterval(() => {\n\t\t\tinvalidate('data:now');\n\t\t}, 1000);\n\n\t\treturn () => {\n\t\t\tclearInterval(interval);\n\t\t};\n\t});\n</script>\n\nNext: invalidateAll\n\nEdit this page\nproject\nsrc\nroutes\n[...timezone]\n+page.js\n+page.svelte\napi\nnow\n+server.js\n+layout.js\n+layout.svelte\n+page.svelte\napp.html\nstatic\nfavicon.png\npackage.json\nsvelte.config.js\nvite.config.js\nsolve \n1\n \ninitialising"
  },
  {
    "title": "Special elements / <svelte:body> • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/svelte-body",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 2\n/\nSpecial elements\n/\n<svelte:body>\n\nSimilar to <svelte:window>, the <svelte:body> element allows you to listen for events that fire on document.body. This is useful with the mouseenter and mouseleave events, which don't fire on window.\n\nAdd these mouseenter and mouseleave handlers to the <svelte:body> tag...\n\nApp.svelte\n<svelte:body\n\ton:mouseenter={() => hereKitty = true}\n\ton:mouseleave={() => hereKitty = false}\n/>\n\n...and hover over the <body>.\n\nNext: <svelte:document>\n\nEdit this page\nsrc\nApp.svelte\nkitten.png\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n⌄\n⌄\n⌄\n⌄\n⌄\n<script>\n\timport kitten from './kitten.png';\n\n\n\tlet hereKitty = false;\n</script>\n\n\n<svelte:body />\n\n\n<!-- creative commons BY-NC http://www.pngall.com/kitten-png/download/7247 -->\n<img\n\tclass:curious={hereKitty}\n\talt=\"Kitten wants to know what's going on\"\n\tsrc={kitten}\n/>\n\n\n<style>\n\timg {\n\t\tposition: absolute;\n\t\tleft: 0;\n\t\tbottom: -60px;\n\t\ttransform: translate(-80%, 0) rotate(-15deg);\n\t\ttransform-origin: 100% 100%;\n\t\ttransition: transform 0.4s;\n\t}\n\n\n\t.curious {\n\t\ttransform: translate(-15%, 0) rotate(0deg);\n\t}\n\n\n\t:global(body) {\n\t\toverflow: hidden;\n\t}\n</style>\n\n\ninitialising"
  },
  {
    "title": "Transitions / Key blocks • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/key-blocks",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 2\n/\nTransitions\n/\nKey blocks\n\nKey blocks destroy and recreate their contents when the value of an expression changes. This is useful if you want an element to play its transition whenever a value changes instead of only when the element enters or leaves the DOM.\n\nHere, for example, we'd like to play the typewriter transition from transition.js whenever the loading message, i.e. i changes. Wrap the <p> element in a key block:\n\nApp.svelte\n{#key i}\n\t<p in:typewriter={{ speed: 10 }}>\n\t\t{messages[i] || ''}\n\t</p>\n{/key}\n\nNext: Deferred transitions\n\nEdit this page\nsrc\nApp.svelte\nloading-messages.js\ntransition.js\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n⌄\n⌄\n⌄\n⌄\n⌄\n<script>\n\timport { onMount } from 'svelte';\n\timport { typewriter } from './transition.js';\n\timport { messages } from './loading-messages.js';\n\n\n\tlet i = -1;\n\n\n\tonMount(() => {\n\t\tconst interval = setInterval(() => {\n\t\t\ti += 1;\n\t\t\ti %= messages.length;\n\t\t}, 2500);\n\n\n\t\treturn () => {\n\t\t\tclearInterval(interval);\n\t\t};\n\t});\n</script>\n\n\n<h1>loading...</h1>\n\n\n<p in:typewriter={{ speed: 10 }}>\n\t{messages[i] || ''}\n</p>\nbooting webcontainer"
  },
  {
    "title": "Bindings / Select multiple • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/multiple-select-bindings",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 1\n/\nBindings\n/\nSelect multiple\n\nA <select> element can have a multiple attribute, in which case it will populate an array rather than selecting a single value.\n\nReplace the checkboxes with a <select multiple>:\n\nApp.svelte\n<h2>Flavours</h2>\n\n<select multiple bind:value={flavours}>\n\t{#each ['cookies and cream', 'mint choc chip', 'raspberry ripple'] as flavour}\n\t\t<option>{flavour}</option>\n\t{/each}\n</select>\n\nNote that we're able to omit the value attribute on the <option>, since the value is identical to the element's contents.\n\nPress and hold the control key (or the command key on MacOS) to select multiple options.\n\nNext: Textarea inputs\n\nEdit this page\nsrc\nApp.svelte\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n⌄\n⌄\n⌄\n⌄\n⌄\n<script>\n\tlet scoops = 1;\n\tlet flavours = [];\n\n\n\tconst formatter = new Intl.ListFormat('en', { style: 'long', type: 'conjunction' });\n</script>\n\n\n<h2>Size</h2>\n\n\n{#each [1, 2, 3] as number}\n\t<label>\n\t\t<input\n\t\t\ttype=\"radio\"\n\t\t\tname=\"scoops\"\n\t\t\tvalue={number}\n\t\t\tbind:group={scoops}\n\t\t/>\n\n\n\t\t{number} {number === 1 ? 'scoop' : 'scoops'}\n\t</label>\n{/each}\n\n\n<h2>Flavours</h2>\n\n\n{#each ['cookies and cream', 'mint choc chip', 'raspberry ripple'] as flavour}\n\t<label>\n\t\t<input\n\t\t\ttype=\"checkbox\"\n\t\t\tname=\"flavours\"\n\t\t\tvalue={flavour}\n\t\t\tbind:group={flavours}\n\t\t/>\n\n\n\t\t{flavour}\n\t</label>\n{/each}\ninitialising"
  },
  {
    "title": "Events / DOM event forwarding • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/dom-event-forwarding",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 1\n/\nEvents\n/\nDOM event forwarding\n\nEvent forwarding works for DOM events too.\n\nWe want to get notified of clicks on our <BigRedButton> — to do that, we just need to forward click events on the <button> element in BigRedButton.svelte:\n\nBigRedButton.svelte\n<button on:click>\n\tPush\n</button>\n\nNext: Bindings\n\nEdit this page\nsrc\nApp.svelte\nBigRedButton.svelte\nhorn.mp3\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n⌄\n⌄\n<script>\n\timport BigRedButton from './BigRedButton.svelte';\n\timport horn from './horn.mp3';\n\n\n\tconst audio = new Audio();\n\taudio.src = horn;\n\n\n\tfunction handleClick() {\n\t\taudio.load();\n\t\taudio.play();\n\t}\n</script>\n\n\n<BigRedButton on:click={handleClick} />\n\n\ninitialising"
  },
  {
    "title": "Logic / Else blocks • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/else-blocks",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 1\n/\nLogic\n/\nElse blocks\n\nJust like in JavaScript, an if block can have an else block:\n\nApp.svelte\n{#if count > 10}\n\t<p>{count} is greater than 10</p>\n{:else}\n\t<p>{count} is between 0 and 10</p>\n{/if}\n\nA # character always indicates a block opening tag. A / character always indicates a block closing tag. A : character, as in {:else}, indicates a block continuation tag. Don't worry — you've already learned almost all the syntax Svelte adds to HTML.\n\nNext: Else-if blocks\n\nEdit this page\nsrc\nApp.svelte\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n⌄\n⌄\n⌄\n⌄\n<script>\n\tlet count = 0;\n\n\n\tfunction increment() {\n\t\tcount += 1;\n\t}\n</script>\n\n\n<button on:click={increment}>\n\tClicked {count}\n\t{count === 1 ? 'time' : 'times'}\n</button>\n\n\n{#if count > 10}\n\t<p>{count} is greater than 10</p>\n{/if}\nbooting webcontainer"
  },
  {
    "title": "Props / Spread props • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/spread-props",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 1\n/\nProps\n/\nSpread props\n\nIn this exercise, we've forgotten to specify the version prop expected by PackageInfo.svelte, meaning it shows 'version undefined'.\n\nWe could fix it by adding the version prop...\n\nApp.svelte\n<PackageInfo\n\tname={pkg.name}\n\tspeed={pkg.speed}\n\tversion={pkg.version}\n\twebsite={pkg.website}\n/>\n\n...but since the properties of pkg correspond to the component's expected props, we can 'spread' them onto the component instead:\n\nApp.svelte\n<PackageInfo {...pkg} />\n\nConversely, if you need to reference all the props that were passed into a component, including ones that weren't declared with export, you can do so by accessing $$props directly. It's not generally recommended, as it's difficult for Svelte to optimise, but it's useful in rare cases.\n\nNext: Logic\n\nEdit this page\nsrc\nApp.svelte\nPackageInfo.svelte\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n⌄\n⌄\n<script>\n\timport PackageInfo from './PackageInfo.svelte';\n\n\n\tconst pkg = {\n\t\tname: 'svelte',\n\t\tspeed: 'blazing',\n\t\tversion: 4,\n\t\twebsite: 'https://svelte.dev'\n\t};\n</script>\n\n\n<PackageInfo\n\tname={pkg.name}\n\tspeed={pkg.speed}\n\twebsite={pkg.website}\n/>\n\n\ninitialising"
  },
  {
    "title": "Advanced loading / Invalidation • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/invalidation",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nTutorial\nSvelte\nSvelteKit\nPart 4\n/\nAdvanced loading\n/\nInvalidation\n\nWhen the user navigates from one page to another, SvelteKit calls your load functions, but only if it thinks something has changed.\n\nIn this example, navigating between timezones causes the load function in src/routes/[...timezone]/+page.js to re-run because params.timezone is invalid. But the load function in src/routes/+layout.js does not re-run, because as far as SvelteKit is concerned it wasn't invalidated by the navigation.\n\nWe can fix that by manually invalidating it using the invalidate(...) function, which takes a URL and re-runs any load functions that depend on it. Because the load function in src/routes/+layout.js calls fetch('/api/now'), it depends on /api/now.\n\nIn src/routes/[...timezone]/+page.svelte, add an onMount callback that calls invalidate('/api/now') once a second:\n\nsrc/routes/[...timezone]/+page.svelte\n<script>\n\timport { onMount } from 'svelte';\n\timport { invalidate } from '$app/navigation';\n\n\texport let data;\n\n\tonMount(() => {\n\t\tconst interval = setInterval(() => {\n\t\t\tinvalidate('/api/now');\n\t\t}, 1000);\n\n\t\treturn () => {\n\t\t\tclearInterval(interval);\n\t\t};\n\t});\n</script>\n\n<h1>\n\t{new Intl.DateTimeFormat([], {\n\t\ttimeStyle: 'full',\n\t\ttimeZone: data.timezone\n\t}).format(new Date(data.now))}\n</h1>\n\nYou can also pass a function to invalidate, in case you want to invalidate based on a pattern and not specific URLs\n\nNext: Custom dependencies\n\nEdit this page\nproject\nsrc\nroutes\n[...timezone]\n+page.js\n+page.svelte\napi\nnow\n+server.js\n+layout.js\n+layout.svelte\n+page.svelte\napp.html\nstatic\nfavicon.png\npackage.json\nsvelte.config.js\nvite.config.js\nsolve \n1\n \ninitialising"
  },
  {
    "title": "Actions / Adding parameters • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/adding-parameters-to-actions",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 2\n/\nActions\n/\nAdding parameters\n\nLike transitions and animations, an action can take an argument, which the action function will be called with alongside the element it belongs to.\n\nIn this exercise, we want to add a tooltip to the <button> using the Tippy.js library. The action is already wired up with use:tooltip, but if you hover over the button (or focus it with the keyboard) the tooltip contains no content.\n\nFirst, the action needs to accept some options and pass them to Tippy:\n\nApp.svelte\nfunction tooltip(node, options) {\n\tconst tooltip = tippy(node, options);\n\n\treturn {\n\t\tdestroy() {\n\t\t\ttooltip.destroy();\n\t\t}\n\t};\n}\n\nThen, we need to pass some options into the action:\n\nApp.svelte\n<button use:tooltip={{ content, theme: 'material' }}>\n\tHover me\n</button>\n\nThe tooltip now works — almost. If we change the text in the <input>, the tooltip will not reflect the new content. We can fix that by adding an update method to the returned object.\n\nApp.svelte\nfunction tooltip(node, options) {\n\tconst tooltip = tippy(node, options);\n\n\treturn {\n\t\tupdate(options) {\n\t\t\ttooltip.setProps(options);\n\t\t},\n\t\tdestroy() {\n\t\t\ttooltip.destroy();\n\t\t}\n\t};\n}\n\nNext: Advanced bindings\n\nEdit this page\nsrc\nApp.svelte\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n⌄\n⌄\n⌄\n⌄\n⌄\n<script>\n\timport tippy from 'tippy.js';\n\timport 'tippy.js/dist/tippy.css';\n\timport 'tippy.js/themes/material.css';\n\n\n\tlet content = 'Hello!';\n\n\n\tfunction tooltip(node) {\n\t\tconst tooltip = tippy(node);\n\n\n\t\treturn {\n\t\t\tdestroy() {\n\t\t\t\ttooltip.destroy();\n\t\t\t}\n\t\t};\n\t}\n</script>\n\n\n<input bind:value={content} />\n\n\n<button use:tooltip>\n\tHover me\n</button>\ninitialising"
  },
  {
    "title": "Advanced bindings / Component bindings • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/component-bindings",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 2\n/\nAdvanced bindings\n/\nComponent bindings\n\nJust as you can bind to properties of DOM elements, you can bind to component props. For example, we can bind to the value prop of this <Keypad> component as though it were a form element:\n\nApp.svelte\n<Keypad\n\tbind:value={pin}\n\ton:submit={handleSubmit}\n/>\n\nNow, when the user interacts with the keypad, the value of pin in the parent component is immediately updated.\n\nUse component bindings sparingly. It can be difficult to track the flow of data around your application if you have too many of them, especially if there is no 'single source of truth'.\n\nNext: Binding to component instances\n\nEdit this page\nsrc\nApp.svelte\nKeypad.svelte\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n⌄\n⌄\n⌄\n<script>\n\timport Keypad from './Keypad.svelte';\n\n\n\tlet pin;\n\t$: view = pin\n\t\t? pin.replace(/\\d(?!$)/g, '•')\n\t\t: 'enter your pin';\n\n\n\tfunction handleSubmit() {\n\t\talert(`submitted ${pin}`);\n\t}\n</script>\n\n\n<h1 style=\"opacity: {pin ? 1 : 0.4}\">\n\t{view}\n</h1>\n\n\n<Keypad\n\ton:submit={handleSubmit}\n/>\n\n\nbooting webcontainer"
  },
  {
    "title": "Special elements / <svelte:document> • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/svelte-document",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 2\n/\nSpecial elements\n/\n<svelte:document>\n\nThe <svelte:document> element allows you to listen for events that fire on document. This is useful with events like selectionchange, which doesn't fire on window.\n\nAdd the selectionchange handler to the <svelte:document> tag:\n\nApp.svelte\n<svelte:document on:selectionchange={handleSelectionChange} />\n\nAvoid mouseenter and mouseleave handlers on this element, as these events are not fired on document in all browsers. Use <svelte:body> instead.\n\nNext: <svelte:head>\n\nEdit this page\nsrc\nApp.svelte\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n⌄\n<script>\n\tlet selection = '';\n\n\n\tconst handleSelectionChange = (e) => selection = document.getSelection();\n</script>\n\n\n<svelte:document />\n\n\n<h1>Select this text to fire events</h1>\n<p>Selection: {selection}</p>\n\n\nbooting webcontainer"
  },
  {
    "title": "Transitions / Global transitions • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/global-transitions",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 2\n/\nTransitions\n/\nGlobal transitions\n\nOrdinarily, transitions will only play on elements when their direct containing block is added or destroyed. In the example here, toggling the visibility of the entire list does not apply transitions to individual list elements.\n\nInstead, we'd like transitions to not only play when individual items are added and removed with the slider but also when we toggle the checkbox.\n\nWe can achieve this with a global transition, which plays when any block containing the transitions is added or removed:\n\nApp.svelte\n<div transition:slide|global>\n\t{item}\n</div>\n\nIn Svelte 3, transitions were global by default and you had to use the |local modifier to make them local.\n\nNext: Key blocks\n\nEdit this page\nsrc\nApp.svelte\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n<script>\n\timport { slide } from 'svelte/transition';\n\n\n\tlet showItems = true;\n\tlet i = 5;\n\tlet items = ['one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'ten'];\n</script>\n\n\n<label>\n\t<input type=\"checkbox\" bind:checked={showItems} />\n\tshow list\n</label>\n\n\n<label>\n\t<input type=\"range\" bind:value={i} max=\"10\" />\n</label>\n\n\n{#if showItems}\n\t{#each items.slice(0, i) as item}\n\t\t<div transition:slide>\n\t\t\t{item}\n\t\t</div>\n\t{/each}\n{/if}\n\n\n<style>\n\tdiv {\n\t\tpadding: 0.5em 0;\n\t\tborder-top: 1px solid #eee;\n\t}\n</style>\n\n\nbooting webcontainer"
  },
  {
    "title": "Bindings / Textarea inputs • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/textarea-inputs",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 1\n/\nBindings\n/\nTextarea inputs\n\nThe <textarea> element behaves similarly to a text input in Svelte — use bind:value:\n\nApp.svelte\n<textarea bind:value={value}></textarea>\n\nIn cases like these, where the names match, we can also use a shorthand form:\n\nApp.svelte\n<textarea bind:value></textarea>\n\nThis applies to all bindings, not just textareas.\n\nNext: Lifecycle\n\nEdit this page\nsrc\nApp.svelte\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n⌄\n⌄\n⌄\n⌄\n⌄\n<script>\n\timport { marked } from 'marked';\n\tlet value = `Some words are *italic*, some are **bold**\\n\\n- lists\\n- are\\n- cool`;\n</script>\n\n\n<div class=\"grid\">\n\tinput\n\t<textarea {value}></textarea>\n\n\n\toutput\n\t<div>{@html marked(value)}</div>\n</div>\n\n\n<style>\n\t.grid {\n\t\tdisplay: grid;\n\t\tgrid-template-columns: 5em 1fr;\n\t\tgrid-template-rows: 1fr 1fr;\n\t\tgrid-gap: 1em;\n\t\theight: 100%;\n\t}\n\n\n\ttextarea {\n\t\tflex: 1;\n\t\tresize: none;\n\t}\n</style>\n\n\nbooting webcontainer"
  },
  {
    "title": "Events / Event forwarding • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/event-forwarding",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 1\n/\nEvents\n/\nEvent forwarding\n\nUnlike DOM events, component events don't bubble. If you want to listen to an event on some deeply nested component, the intermediate components must forward the event.\n\nIn this case, we have the same App.svelte and Inner.svelte as in the previous chapter, but there's now an Outer.svelte component that contains <Inner/>.\n\nOne way we could solve the problem is adding createEventDispatcher to Outer.svelte, listening for the message event, and creating a handler for it:\n\nOuter.svelte\n<script>\n\timport Inner from './Inner.svelte';\n\timport { createEventDispatcher } from 'svelte';\n\n\tconst dispatch = createEventDispatcher();\n\n\tfunction forward(event) {\n\t\tdispatch('message', event.detail);\n\t}\n</script>\n\n<Inner on:message={forward}/>\n\nBut that's a lot of code to write, so Svelte gives us an equivalent shorthand — an on:message event directive without a value means 'forward all message events'.\n\nOuter.svelte\n<script>\n\timport Inner from './Inner.svelte';\n</script>\n\n<Inner on:message/>\n\nNext: DOM event forwarding\n\nEdit this page\nsrc\nApp.svelte\nInner.svelte\nOuter.svelte\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n⌄\n⌄\n<script>\n\timport Outer from './Outer.svelte';\n\n\n\tfunction handleMessage(event) {\n\t\talert(event.detail.text);\n\t}\n</script>\n\n\n<Outer on:message={handleMessage} />\n\n\nbooting webcontainer"
  },
  {
    "title": "Stores / updated • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/updated-store",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 3\n/\nStores\n/\nupdated\n\nThe updated store contains true or false depending on whether a new version of the app has been deployed since the page was first opened. For this to work, your svelte.config.js must specify kit.version.pollInterval.\n\nsrc/routes/+layout.svelte\n<script>\n\timport { page, navigating, updated } from '$app/stores';\n</script>\n\nVersion changes only happen in production, not during development. For that reason, $updated will always be false in this tutorial.\n\nYou can manually check for new versions, regardless of pollInterval, by calling updated.check().\n\nsrc/routes/+layout.svelte\n\n{#if $updated}\n\t<div class=\"toast\">\n\t\t<p>\n\t\t\tA new version of the app is available\n\n\t\t\t<button on:click={() => location.reload()}>\n\t\t\t\treload the page\n\t\t\t</button>\n\t\t</p>\n\t</div>\n{/if}\n\nNext: Errors and redirects\n\nEdit this page\nproject\nsrc\nroutes\nabout\n+page.server.js\n+page.svelte\n+layout.svelte\n+page.server.js\n+page.svelte\napp.html\nstatic\nfavicon.png\npackage.json\nsvelte.config.js\nvite.config.js\nsolve \n1\n2\n3\n<h1>home</h1>\n<p>this is the home page.</p>\n\n\nbooting webcontainer"
  },
  {
    "title": "Logic / Else-if blocks • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/else-if-blocks",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 1\n/\nLogic\n/\nElse-if blocks\n\nMultiple conditions can be 'chained' together with else if:\n\nApp.svelte\n{#if count > 10}\n\t<p>{count} is greater than 10</p>\n{:else if count < 5}\n\t<p>{count} is less than 5</p>\n{:else}\n\t<p>{count} is between 5 and 10</p>\n{/if}\n\nNext: Each blocks\n\nEdit this page\nsrc\nApp.svelte\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n⌄\n⌄\n⌄\n⌄\n<script>\n\tlet count = 0;\n\n\n\tfunction increment() {\n\t\tcount += 1;\n\t}\n</script>\n\n\n<button on:click={increment}>\n\tClicked {count}\n\t{count === 1 ? 'time' : 'times'}\n</button>\n\n\n{#if count > 10}\n\t<p>{count} is greater than 10</p>\n{:else}\n\t<p>{count} is between 0 and 10</p>\n{/if}\nbooting webcontainer"
  },
  {
    "title": "Props / Default values • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/default-values",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 1\n/\nProps\n/\nDefault values\n\nWe can easily specify default values for props in Nested.svelte:\n\nNested.svelte\n<script>\n\texport let answer = 'a mystery';\n</script>\n\nIf we now add a second component without an answer prop, it will fall back to the default:\n\nApp.svelte\n<Nested answer={42}/>\n<Nested />\n\nNext: Spread props\n\nEdit this page\nsrc\nApp.svelte\nNested.svelte\nsolve \n1\n2\n3\n4\n5\n6\n⌄\n<script>\n\timport Nested from './Nested.svelte';\n</script>\n\n\n<Nested answer={42} />\n\n\nbooting webcontainer"
  },
  {
    "title": "Stores / navigating • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/navigating-store",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 3\n/\nStores\n/\nnavigating\n\nThe navigating store represents the current navigation. When a navigation starts — because of a link click, or a back/forward navigation, or a programmatic goto — the value of navigation will become an object with the following properties:\n\nfrom and to — objects with params, route and url properties\ntype — the type of navigation, e.g. link, popstate or goto\n\nFor complete type information visit the Navigation documentation.\n\nIt can be used to show a loading indicator for long-running navigations. In this exercise, src/routes/+page.server.js and src/routes/about/+page.server.js both have an artificial delay. Inside src/routes/+layout.svelte, import the navigating store and add a message to the nav bar:\n\nsrc/routes/+layout.svelte\n<script>\n\timport { page, navigating } from '$app/stores';\n</script>\n\n<nav>\n\t<a href=\"/\" aria-current={$page.url.pathname === '/'}>\n\t\thome\n\t</a>\n\n\t<a href=\"/about\" aria-current={$page.url.pathname === '/about'}>\n\t\tabout\n\t</a>\n\n\t{#if $navigating}\n\t\tnavigating to {$navigating.to.url.pathname}\n\t{/if}\n</nav>\n\n<slot />\n\nNext: updated\n\nEdit this page\nproject\nsrc\nroutes\nabout\n+page.server.js\n+page.svelte\n+layout.svelte\n+page.server.js\n+page.svelte\napp.html\nstatic\nfavicon.png\npackage.json\nsvelte.config.js\nvite.config.js\nsolve \n1\n2\n3\n<h1>home</h1>\n<p>this is the home page.</p>\n\n\ninitialising"
  },
  {
    "title": "Advanced loading / Using parent data • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/await-parent",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 4\n/\nAdvanced loading\n/\nUsing parent data\n\nAs we saw in the introduction to layout data, +page.svelte and +layout.svelte components have access to everything returned from their parent load functions.\n\nOccasionally it's useful for the load functions themselves to access data from their parents. This can be done with await parent().\n\nTo show how it works, we'll sum two numbers that come from different load functions. First, return some data from src/routes/+layout.server.js:\n\nsrc/routes/+layout.server.js\nexport function load() {\n\treturn { a: 1 };\n}\n\nThen, get that data in src/routes/sum/+layout.js:\n\nsrc/routes/sum/+layout.js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n\nNotice that a universal load function can get data from a parent server load function. The reverse is not true — a server load function can only get parent data from another server load function.\n\nFinally, in src/routes/sum/+page.js, get parent data from both load functions:\n\nsrc/routes/sum/+page.js\nexport async function load({ parent }) {\n\tconst { a, b } = await parent();\n\treturn { c: a + b };\n}\n\nTake care not to introduce waterfalls when using await parent(). If you can fetch other data that is not dependent on parent data, do that first.\n\nNext: Invalidation\n\nEdit this page\nproject\nsrc\nroutes\nsum\n+layout.js\n+page.js\n+page.svelte\n+layout.server.js\n+page.svelte\napp.html\nstatic\nfavicon.png\npackage.json\nsvelte.config.js\nvite.config.js\nsolve \n1\n2\n3\n<p>if a = 1 and b = a + 1, what is a + b?</p>\n<a href=\"/sum\">show answer</a>\n\n\nbooting webcontainer"
  },
  {
    "title": "Advanced bindings / Contenteditable bindings • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/contenteditable-bindings",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 2\n/\nAdvanced bindings\n/\nContenteditable bindings\n\nElements with a contenteditable attribute support textContent and innerHTML bindings:\n\nApp.svelte\n<div bind:innerHTML={html} contenteditable />\n\nNext: Each block bindings\n\nEdit this page\nsrc\nApp.svelte\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n⌄\n⌄\n⌄\n<script>\n\tlet html = '<p>Write some text!</p>';\n</script>\n\n\n<div contenteditable />\n\n\n<pre>{html}</pre>\n\n\n<style>\n\t[contenteditable] {\n\t\tpadding: 0.5em;\n\t\tborder: 1px solid #eee;\n\t\tborder-radius: 4px;\n\t}\n</style>\n\n\ninitialising"
  },
  {
    "title": "Advanced bindings / This • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/bind-this",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 2\n/\nAdvanced bindings\n/\nThis\n\nIn a previous exercise, we learned how to use the onMount lifecycle function to paint to a canvas.\n\nBut the example is buggy — it's using document.querySelector('canvas'), which will always return the first <canvas> found on the page, which might not be the one belonging to our component.\n\nInstead, we can use the readonly this binding to get a reference to the element:\n\nApp.svelte\nlet canvas;\n\nonMount(() => {\n\tconst canvas = document.querySelector('canvas')\n\tconst context = canvas.getContext('2d');\n\n\tlet frame = requestAnimationFrame(function loop(t) {\n\t\tframe = requestAnimationFrame(loop);\n\t\tpaint(context, t);\n\t});\n\n\treturn () => {\n\t\tcancelAnimationFrame(frame);\n\t};\n});\nApp.svelte\n<canvas\n\tbind:this={canvas}\n\twidth={32}\n\theight={32}\n></canvas>\n\nNote that the value of canvas will be undefined until the component has mounted.\n\nNext: Component bindings\n\nEdit this page\nsrc\nApp.svelte\ngradient.js\nsvelte-logo-mask.svg\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n<script>\n\timport { onMount } from 'svelte';\n\timport { paint } from './gradient.js';\n\n\n\tonMount(() => {\n\t\tconst canvas = document.querySelector('canvas')\n\t\tconst context = canvas.getContext('2d');\n\n\n\t\tlet frame = requestAnimationFrame(function loop(t) {\n\t\t\tframe = requestAnimationFrame(loop);\n\t\t\tpaint(context, t);\n\t\t});\n\n\n\t\treturn () => {\n\t\t\tcancelAnimationFrame(frame);\n\t\t};\n\t});\n</script>\n\n\n<canvas\n\twidth={32}\n\theight={32}\n/>\n\n\n<style>\n\tcanvas {\n\t\tposition: fixed;\n\t\tleft: 0;\n\t\ttop: 0;\n\t\twidth: 100%;\n\t\theight: 100%;\n\t\tbackground-color: #666;\n\t\tmask: url(./svelte-logo-mask.svg) 50% 50% no-repeat;\n\t\tmask-size: 60vmin;\n\t\t-webkit-mask: url(./svelte-logo-mask.svg) 50% 50% no-repeat;\n\t\t-webkit-mask-size: 60vmin;\nbooting webcontainer"
  },
  {
    "title": "Special elements / <svelte:head> • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/svelte-head",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 2\n/\nSpecial elements\n/\n<svelte:head>\n\nThe <svelte:head> element allows you to insert elements inside the <head> of your document. This is useful for things like <title> and <meta> tags, which are critical for good SEO.\n\nSince those are quite hard to show in the context of this tutorial, we'll use it for a different purpose — loading stylesheets.\n\nApp.svelte\n<script>\n\tconst themes = ['margaritaville', 'retrowave', 'spaaaaace', 'halloween'];\n\tlet selected = themes[0];\n</script>\n\n<svelte:head>\n\t<link rel=\"stylesheet\" href=\"/stylesheets/{selected}.css\" />\n</svelte:head>\n\n<h1>Welcome to my site!</h1>\n\nIn server-side rendering (SSR) mode, contents of <svelte:head> are returned separately from the rest of your HTML.\n\nNext: <svelte:options>\n\nEdit this page\nsrc\nApp.svelte\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n⌄\n⌄\n⌄\n<script>\n\tconst themes = ['margaritaville', 'retrowave', 'spaaaaace', 'halloween'];\n\tlet selected = themes[0];\n</script>\n\n\n<h1>Welcome to my site!</h1>\n\n\n<select bind:value={selected}>\n\t<option disabled>choose a theme</option>\n\n\n\t{#each themes as theme}\n\t\t<option>{theme}</option>\n\t{/each}\n</select>\ninitialising"
  },
  {
    "title": "Transitions / Transition events • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/transition-events",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 2\n/\nTransitions\n/\nTransition events\n\nIt can be useful to know when transitions are beginning and ending. Svelte dispatches events that you can listen to like any other DOM event:\n\nApp.svelte\n<p\n\ttransition:fly={{ y: 200, duration: 2000 }}\n\ton:introstart={() => status = 'intro started'}\n\ton:outrostart={() => status = 'outro started'}\n\ton:introend={() => status = 'intro ended'}\n\ton:outroend={() => status = 'outro ended'}\n>\n\tFlies in and out\n</p>\n\nNext: Global transitions\n\nEdit this page\nsrc\nApp.svelte\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n⌄\n⌄\n⌄\n⌄\n<script>\n\timport { fly } from 'svelte/transition';\n\n\n\tlet visible = true;\n\tlet status = 'waiting...';\n</script>\n\n\n<p>status: {status}</p>\n\n\n<label>\n\t<input type=\"checkbox\" bind:checked={visible} />\n\tvisible\n</label>\n\n\n{#if visible}\n\t<p transition:fly={{ y: 200, duration: 2000 }}>\n\t\tFlies in and out\n\t</p>\n{/if}\n\n\nbooting webcontainer"
  },
  {
    "title": "Page options / Basics • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/page-options",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 4\n/\nPage options\n/\nBasics\n\nIn the chapter on loading data, we saw how you can export load functions from +page.js, +page.server.js, +layout.js and +layout.server.js files. We can also export various page options from these modules:\n\nssr — whether or not pages should be server-rendered\ncsr — whether to load the SvelteKit client\nprerender — whether to prerender pages at build time, instead of per-request\ntrailingSlash — whether to strip, add, or ignore trailing slashes in URLs\n\nIn the following exercises, we'll learn about each of these in turn.\n\nPage options can apply to individual pages (if exported from +page.js or +page.server.js), or groups of pages (if exported from +layout.js or +layout.server.js). To define an option for the whole app, export it from the root layout. Child layouts and pages override values set in parent layouts, so — for example — you can enable prerendering for your entire app then disable it for pages that need to be dynamically rendered.\n\nYou can mix and match these options in different areas of your app — you could prerender your marketing pages, dynamically server-render your data-driven pages, and treat your admin pages as a client-rendered SPA. This makes SvelteKit very versatile.\n\nNext: ssr\n\nEdit this page\nproject\nsrc\nroutes\n+page.svelte\napp.html\nstatic\nfavicon.png\npackage.json\nsvelte.config.js\nvite.config.js\nsolve \n1\n2\n<h2>Page options</h2>\n\n\ninitialising"
  },
  {
    "title": "Errors and redirects / Basics • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/error-basics",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 3\n/\nErrors and redirects\n/\nBasics\n\nThere are two types of errors in SvelteKit — expected errors and unexpected errors.\n\nAn expected error is one that was created with the error helper from @sveltejs/kit, as in src/routes/expected/+page.server.js:\n\nsrc/routes/expected/+page.server.js\nimport { error } from '@sveltejs/kit';\n\nexport function load() {\n\tthrow error(420, 'Enhance your calm');\n}\n\nAny other error — such as the one in src/routes/unexpected/+page.server.js — is treated as unexpected:\n\nsrc/routes/unexpected/+page.server.js\nexport function load() {\n\tthrow new Error('Kaboom!');\n}\n\nWhen you throw an expected error, you're telling SvelteKit 'don't worry, I know what I'm doing here'. An unexpected error, by contrast, is assumed to be a bug in your app. When an unexpected error is thrown, its message and stack trace will be logged to the console.\n\nIn a later chapter we'll learn about how to add custom error handling using the handleError hook.\n\nIf you click the links in this app, you'll notice an important difference: the expected error message is shown to the user, whereas the unexpected error message is redacted and replaced with a generic 'Internal Error' message and a 500 status code. That's because error messages can contain sensitive data.\n\nNext: Error pages\n\nEdit this page\nproject\nsrc\nroutes\nexpected\n+page.server.js\n+page.svelte\nunexpected\n+page.server.js\n+page.svelte\n+layout.svelte\n+page.svelte\nemojis.js\napp.html\nstatic\nfavicon.png\npackage.json\nsvelte.config.js\nvite.config.js\nsolve \n1\n2\n<h1>home</h1>\n\n\nbooting webcontainer"
  },
  {
    "title": "Lifecycle / onMount • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/onmount",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 1\n/\nLifecycle\n/\nonMount\n\nEvery component has a lifecycle that starts when it is created, and ends when it is destroyed. There are a handful of functions that allow you to run code at key moments during that lifecycle. The one you'll use most frequently is onMount, which runs after the component is first rendered to the DOM.\n\nIn this exercise, we have a <canvas> that we'd like to animate, using the paint function in gradient.js. Begin by importing the onMount function from svelte:\n\nApp.svelte\n<script>\n\timport { onMount } from 'svelte';\n\timport { paint } from './gradient.js';\n</script>\n\nThen, add a callback that runs when the component mounts:\n\nApp.svelte\n<script>\n\timport { onMount } from 'svelte';\n\timport { paint } from './gradient.js';\n\n\tonMount(() => {\n\t\tconst canvas = document.querySelector('canvas');\n\t\tconst context = canvas.getContext('2d');\n\n\t\trequestAnimationFrame(function loop(t) {\n\t\t\trequestAnimationFrame(loop);\n\t\t\tpaint(context, t);\n\t\t});\n\t});\n</script>\n\nIn a later exercise, we'll learn how to get an element reference without using document.querySelector.\n\nSo far so good — you should see gently undulating colours in the shape of the Svelte logo. But there's one problem — the loop will continue even after the component has been destroyed. To fix that, we need to return a cleanup function from onMount:\n\nApp.svelte\nonMount(() => {\n\tconst canvas = document.querySelector('canvas')\n\tconst context = canvas.getContext('2d');\n\n\tlet frame = requestAnimationFrame(function loop(t) {\n\t\tframe = requestAnimationFrame(loop);\n\t\tpaint(context, t);\n\t});\n\n\treturn () => {\n\t\tcancelAnimationFrame(frame);\n\t};\n});\n\nNext: beforeUpdate and afterUpdate\n\nEdit this page\nsrc\nApp.svelte\ngradient.js\nsvelte-logo-mask.svg\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n⌄\n⌄\n⌄\n<script>\n\timport { paint } from './gradient.js';\n</script>\n\n\n<canvas\n\twidth={32}\n\theight={32}\n/>\n\n\n<style>\n\tcanvas {\n\t\tposition: fixed;\n\t\tleft: 0;\n\t\ttop: 0;\n\t\twidth: 100%;\n\t\theight: 100%;\n\t\tbackground-color: #666;\n\t\tmask: url(./svelte-logo-mask.svg) 50% 50% no-repeat;\n\t\tmask-size: 60vmin;\n\t\t-webkit-mask: url(./svelte-logo-mask.svg) 50% 50% no-repeat;\n\t\t-webkit-mask-size: 60vmin;\n\t}\n</style>\n\n\ninitialising"
  },
  {
    "title": "Logic / Each blocks • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/each-blocks",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 1\n/\nLogic\n/\nEach blocks\n\nWhen building user interfaces you'll often find yourself working with lists of data. In this exercise, we've repeated the <button> markup multiple times — changing the colour each time — but there's still more to add.\n\nInstead of laboriously copying, pasting and editing, we can get rid of all but the first button, then use an each block:\n\nApp.svelte\n<div>\n\t{#each colors as color}\n\t\t<button\n\t\t\taria-current={selected === 'red'}\n\t\t\taria-label=\"red\"\n\t\t\tstyle=\"background: red\"\n\t\t\ton:click={() => selected = 'red'}\n\t\t></button>\n\t{/each}\n</div>\n\nThe expression (colors, in this case) can be any array or array-like object (i.e. it has a length property). You can loop over generic iterables with each [...iterable].\n\nNow we need to use the color variable in place of \"red\":\n\nApp.svelte\n<div>\n\t{#each colors as color}\n\t\t<button\n\t\t\taria-current={selected === color}\n\t\t\taria-label={color}\n\t\t\tstyle=\"background: {color}\"\n\t\t\ton:click={() => selected = color}\n\t\t></button>\n\t{/each}\n</div>\n\nYou can get the current index as a second argument, like so:\n\nApp.svelte\n<div>\n\t{#each colors as color, i}\n\t\t<button\n\t\t\taria-current={selected === color}\n\t\t\taria-label={color}\n\t\t\tstyle=\"background: {color}\"\n\t\t\ton:click={() => selected = color}\n\t\t>{i + 1}</button>\n\t{/each}\n</div>\n\nNext: Keyed each blocks\n\nEdit this page\nsrc\nApp.svelte\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n⌄\n⌄\n<script>\n\tconst colors = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'];\n\tlet selected = colors[0];\n</script>\n\n\n<h1 style=\"color: {selected}\">Pick a colour</h1>\n\n\n<div>\n\t<button\n\t\taria-current={selected === 'red'}\n\t\taria-label=\"red\"\n\t\tstyle=\"background: red\"\n\t\ton:click={() => selected = 'red'}\n\t></button>\n\n\n\t<button\n\t\taria-current={selected === 'orange'}\n\t\taria-label=\"orange\"\n\t\tstyle=\"background: orange\"\n\t\ton:click={() => selected = 'orange'}\n\t></button>\n\n\n\t<button\n\t\taria-current={selected === 'yellow'}\n\t\taria-label=\"yellow\"\n\t\tstyle=\"background: yellow\"\n\t\ton:click={() => selected = 'yellow'}\n\t></button>\n\n\n\t<!-- TODO add the rest of the colours -->\n\t<button></button>\n\t<button></button>\n\t<button></button>\n\t<button></button>\n</div>\n\n\nbooting webcontainer"
  },
  {
    "title": "Events / Component events • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/component-events",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nTutorial\nSvelte\nSvelteKit\nPart 1\n/\nEvents\n/\nComponent events\n\nComponents can also dispatch events. To do so, they must create an event dispatcher. Update Inner.svelte:\n\nInner.svelte\n<script>\n\timport { createEventDispatcher } from 'svelte';\n\n\tconst dispatch = createEventDispatcher();\n\n\tfunction sayHello() {\n\t\tdispatch('message', {\n\t\t\ttext: 'Hello!'\n\t\t});\n\t}\n</script>\n\ncreateEventDispatcher must be called when the component is first instantiated — you can't do it later inside e.g. a setTimeout callback. This links dispatch to the component instance.\n\nThen, add an on:message handler in App.svelte:\n\nApp.svelte\n<Inner on:message={handleMessage} />\n\nYou can also try changing the event name to something else. For instance, change dispatch('message', {...}) to dispatch('greet', {...}) in Inner.svelte and change the attribute name from on:message to on:greet in App.svelte.\n\nNext: Event forwarding\n\nEdit this page\nsrc\nApp.svelte\nInner.svelte\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n<script>\n\timport Inner from './Inner.svelte';\n \n\tfunction handleMessage(event) {\n\t\talert(event.detail.text);\n\t}\n</script>\n \n<Inner />\n \ninitialising"
  },
  {
    "title": "Stores / page • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/page-store",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 3\n/\nStores\n/\npage\n\nAs we learned earlier, Svelte stores are a place to put data that doesn't belong to an individual component.\n\nSvelteKit makes three readonly stores available via the $app/stores module — page, navigating and updated. The one you'll use most often is page, which provides information about the current page:\n\nurl — the URL of the current page\nparams — the current page's parameters\nroute — an object with an id property representing the current route\nstatus — the HTTP status code of the current page\nerror — the error object of the current page, if any (you'll learn more about error handling in later exercises)\ndata — the data for the current page, combining the return values of all load functions\nform — the data returned from a form action\n\nAs with any other store, you can reference its value in a component by prefixing its name with the $ symbol. For example, we can access the current pathname as $page.url.pathname:\n\nsrc/routes/+layout.svelte\n<script>\n\timport { page } from '$app/stores';\n</script>\n\n<nav>\n\t<a href=\"/\" aria-current={$page.url.pathname === '/'}>\n\t\thome\n\t</a>\n\n\t<a href=\"/about\" aria-current={$page.url.pathname === '/about'}>\n\t\tabout\n\t</a>\n</nav>\n\n<slot />\n\nNext: navigating\n\nEdit this page\nproject\nsrc\nroutes\nabout\n+page.svelte\n+layout.svelte\n+page.svelte\napp.html\nstatic\nfavicon.png\npackage.json\nsvelte.config.js\nvite.config.js\nsolve \n1\n2\n3\n<h1>home</h1>\n<p>this is the home page.</p>\n\n\ninitialising"
  },
  {
    "title": "Props / Declaring props • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/declaring-props",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nTutorial\nSvelte\nSvelteKit\nPart 1\n/\nProps\n/\nDeclaring props\n\nSo far, we've dealt exclusively with internal state — that is to say, the values are only accessible within a given component.\n\nIn any real application, you'll need to pass data from one component down to its children. To do that, we need to declare properties, generally shortened to 'props'. In Svelte, we do that with the export keyword. Edit the Nested.svelte component:\n\nNested.svelte\n<script>\n\texport let answer;\n</script>\n\nJust like $:, this may feel a little weird at first. That's not how export normally works in JavaScript modules! Just roll with it for now — it'll soon become second nature.\n\nNext: Default values\n\nEdit this page\nsrc\nApp.svelte\nNested.svelte\nsolve \n1\n2\n3\n4\n5\n6\n<script>\n\timport Nested from './Nested.svelte';\n</script>\n \n<Nested answer={42} />\n \ninitialising"
  },
  {
    "title": "Forms / Named form actions • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/named-form-actions",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 3\n/\nForms\n/\nNamed form actions\n\nA page that only has a single action is, in practice, quite rare. Most of the time you'll need to have multiple actions on a page. In this app, creating a todo isn't enough — we'd like to delete them once they're complete.\n\nBegin by replacing our default action with named create and delete actions:\n\nsrc/routes/+page.server.js\nexport const actions = {\n\tcreate: async ({ cookies, request }) => {\n\t\tconst data = await request.formData();\n\t\tdb.createTodo(cookies.get('userid'), data.get('description'));\n\t},\n\n\tdelete: async ({ cookies, request }) => {\n\t\tconst data = await request.formData();\n\t\tdb.deleteTodo(cookies.get('userid'), data.get('id'));\n\t}\n};\n\nDefault actions cannot coexist with named actions.\n\nThe <form> element has an optional action attribute, which is similar to an <a> element's href attribute. Update the existing form so that it points to the new create action:\n\nsrc/routes/+page.svelte\n<form method=\"POST\" action=\"?/create\">\n\t<label>\n\t\tadd a todo:\n\t\t<input\n\t\t\tname=\"description\"\n\t\t\tautocomplete=\"off\"\n\t\t/>\n\t</label>\n</form>\n\nThe action attribute can be any URL — if the action was defined on another page, you might have something like /todos?/create. Since the action is on this page, we can omit the pathname altogether, hence the leading ? character.\n\nNext, we want to create a form for each todo, complete with a hidden <input> that uniquely identifies it:\n\nsrc/routes/+page.svelte\n<ul class=\"todos\">\n\t{#each data.todos as todo (todo.id)}\n\t\t<li>\n\t\t\t<form method=\"POST\" action=\"?/delete\">\n\t\t\t\t<input type=\"hidden\" name=\"id\" value={todo.id} />\n\t\t\t\t<span>{todo.description}</span>\n\t\t\t\t<button aria-label=\"Mark as complete\" />\n\t\t\t</form>\n\t\t</li>\n\t{/each}\n</ul>\n\nNext: Validation\n\nEdit this page\nproject\nsrc\nlib\nserver\ndatabase.js\nroutes\n+page.server.js\n+page.svelte\nremove.svg\napp.html\nstatic\nfavicon.png\npackage.json\nsvelte.config.js\nvite.config.js\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n<script>\n\texport let data;\n</script>\n\n\n<div class=\"centered\">\n\t<h1>todos</h1>\n\n\n\t<form method=\"POST\">\n\t\t<label>\n\t\t\tadd a todo:\n\t\t\t<input\n\t\t\t\tname=\"description\"\n\t\t\t\tautocomplete=\"off\"\n\t\t\t/>\n\t\t</label>\n\t</form>\n\n\n\t<ul class=\"todos\">\n\t\t{#each data.todos as todo (todo.id)}\n\t\t\t<li>\n\t\t\t\t{todo.description}\n\t\t\t</li>\n\t\t{/each}\n\t</ul>\n</div>\n\n\n<style>\n\t.centered {\n\t\tmax-width: 20em;\n\t\tmargin: 0 auto;\n\t}\n\n\n\tlabel {\n\t\twidth: 100%;\n\t}\n\n\ninitialising"
  },
  {
    "title": "Advanced loading / Using both load functions • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/using-both-load-functions",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 4\n/\nAdvanced loading\n/\nUsing both load functions\n\nOccasionally, you might need to use a server load function and a universal load function together. For example, you might need to return data from the server, but also return a value that can't be serialized as server data.\n\nIn this example we want to return a different component from load depending on whether the data we got from src/routes/+page.server.js is cool or not.\n\nWe can access server data in src/routes/+page.js via the data property:\n\nsrc/routes/+page.js\nexport async function load({ data }) {\n\tconst module = data.cool\n\t\t? await import('./CoolComponent.svelte')\n\t\t: await import('./BoringComponent.svelte');\n\n\treturn {\n\t\tcomponent: module.default,\n\t\tmessage: data.message\n\t};\n}\n\nNote that the data isn't merged — we must explicitly return message from the universal load function.\n\nNext: Using parent data\n\nEdit this page\nproject\nsrc\nroutes\n+page.js\n+page.server.js\n+page.svelte\nBoringComponent.svelte\nCoolComponent.svelte\napp.html\nstatic\nfavicon.png\npackage.json\nsvelte.config.js\nvite.config.js\nsolve \n1\n2\n3\n4\n5\n6\n⌄\n<script>\n\texport let data;\n</script>\n\n\n<svelte:component this={data.component} message={data.message} />\n\n\ninitialising"
  },
  {
    "title": "Shared modules / The $lib alias • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/lib",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 3\n/\nShared modules\n/\nThe $lib alias\n\nBecause SvelteKit uses directory-based routing, it's easy to place modules and components alongside the routes that use them. A good rule of thumb is 'put code close to where it's used'.\n\nSometimes, code is used in multiple places. When this happens, it's useful to have a place to put them that can be accessed by all routes without needing to prefix imports with ../../../../. In SvelteKit, that place is the src/lib directory. Anything inside this directory can be accessed by any module in src via the $lib alias.\n\nBoth +page.svelte files in this exercise import src/lib/message.js. But if you navigate to /a/deeply/nested/route, the app breaks, because we got the prefix wrong. Update it to use $lib/message.js instead:\n\nsrc/routes/a/deeply/nested/route/+page.svelte\n<script>\n\timport { message } from '$lib/message.js';\n</script>\n\n<h1>a deeply nested route</h1>\n<p>{message}</p>\n\nDo the same for src/routes/+page.svelte:\n\nsrc/routes/+page.svelte\n<script>\n\timport { message } from '$lib/message.js';\n</script>\n\n<h1>home</h1>\n<p>{message}</p>\n\nNext: Forms\n\nEdit this page\nproject\nsrc\nlib\nmessage.js\nroutes\na\ndeeply\nnested\nroute\n+page.svelte\n+layout.svelte\n+page.svelte\napp.html\nstatic\nfavicon.png\npackage.json\nsvelte.config.js\nvite.config.js\nsolve \n1\n2\n3\n4\n5\n6\n⌄\n<script>\n\timport { message } from '../lib/message.js';\n</script>\n\n\n<h1>home</h1>\n<p>{message}</p>\nbooting webcontainer"
  },
  {
    "title": "Advanced bindings / Each block bindings • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/each-block-bindings",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 2\n/\nAdvanced bindings\n/\nEach block bindings\n\nYou can even bind to properties inside an each block.\n\nApp.svelte\n{#each todos as todo}\n\t<li class:done={todo.done}>\n\t\t<input\n\t\t\ttype=\"checkbox\"\n\t\t\tbind:checked={todo.done}\n\t\t/>\n\n\t\t<input\n\t\t\ttype=\"text\"\n\t\t\tplaceholder=\"What needs to be done?\"\n\t\t\tbind:value={todo.text}\n\t\t/>\n\t</li>\n{/each}\n\nNote that interacting with these <input> elements will mutate the array. If you prefer to work with immutable data, you should avoid these bindings and use event handlers instead.\n\nNext: Media elements\n\nEdit this page\nsrc\nApp.svelte\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n<script>\n\tlet todos = [\n\t\t{ done: false, text: 'finish Svelte tutorial' },\n\t\t{ done: false, text: 'build an app' },\n\t\t{ done: false, text: 'world domination' }\n\t];\n\n\n\tfunction add() {\n\t\ttodos = todos.concat({\n\t\t\tdone: false,\n\t\t\ttext: ''\n\t\t});\n\t}\n\n\n\tfunction clear() {\n\t\ttodos = todos.filter((t) => !t.done);\n\t}\n\n\n\t$: remaining = todos.filter((t) => !t.done).length;\n</script>\n\n\n<div class=\"centered\">\n\t<h1>todos</h1>\n\n\n\t<ul class=\"todos\">\n\t\t{#each todos as todo}\n\t\t\t<li class:done={todo.done}>\n\t\t\t\t<input\n\t\t\t\t\ttype=\"checkbox\"\n\t\t\t\t\tchecked={todo.done}\n\t\t\t\t/>\n\n\n\t\t\t\t<input\n\t\t\t\t\ttype=\"text\"\n\t\t\t\t\tplaceholder=\"What needs to be done?\"\n\t\t\t\t\tvalue={todo.text}\ninitialising"
  },
  {
    "title": "Advanced bindings / Dimensions • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/dimensions",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 2\n/\nAdvanced bindings\n/\nDimensions\n\nEvery block-level element has clientWidth, clientHeight, offsetWidth and offsetHeight bindings:\n\nApp.svelte\n<div bind:clientWidth={w} bind:clientHeight={h}>\n\t<span style=\"font-size: {size}px\" contenteditable>{text}</span>\n\t<span class=\"size\">{w} x {h}px</span>\n</div>\n\nThese bindings are readonly — changing the values of w and h won't have any effect on the element.\n\nElements are measured using a technique similar to this one. There is some overhead involved, so it's not recommended to use this for large numbers of elements.\n\ndisplay: inline elements cannot be measured with this approach; nor can elements that can't contain other elements (such as <canvas>). In these cases you will need to measure a wrapper element instead.\n\nNext: This\n\nEdit this page\nsrc\nApp.svelte\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n<script>\n\tlet w;\n\tlet h;\n\tlet size = 42;\n\tlet text = 'edit this text';\n</script>\n\n\n<label>\n\t<input type=\"range\" bind:value={size} min=\"10\" max=\"100\" />\n\tfont size ({size}px)\n</label>\n\n\n<div>\n\t<span style=\"font-size: {size}px\" contenteditable>{text}</span>\n\t<span class=\"size\">{w} x {h}px</span>\n</div>\n\n\n<style>\n\tdiv {\n\t\tposition: relative;\n\t\tdisplay: inline-block;\n\t\tpadding: 0.5rem;\n\t\tbackground: hsla(15, 100%, 50%, 0.1);\n\t\tborder: 1px solid hsl(15, 100%, 50%);\n\t}\n\n\n\t.size {\n\t\tposition: absolute;\n\t\tright: -1px;\n\t\tbottom: -1.4em;\n\t\tline-height: 1;\n\t\tbackground: hsl(15, 100%, 50%);\n\t\tcolor: white;\n\t\tpadding: 0.2em 0.5em;\n\t\twhite-space: pre;\n\t}\ninitialising"
  },
  {
    "title": "Special elements / <svelte:options> • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/svelte-options",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 2\n/\nSpecial elements\n/\n<svelte:options>\n\nThe <svelte:options> element allows you to specify compiler options.\n\nWe'll use the immutable option as an example. In this app, the <Todo> component flashes whenever it receives new data. Clicking on one of the items toggles its done state by creating an updated todos array. This causes the other <Todo> items to flash, even though they don't end up making any changes to the DOM.\n\nWe can optimise this by telling the <Todo> component to expect immutable data. This means that we're promising never to mutate the todo prop, but will instead create new todo objects whenever things change.\n\nAdd this to the top of Todo.svelte:\n\nTodo.svelte\n<svelte:options immutable={true} />\n\nYou can shorten this to <svelte:options immutable/> if you prefer.\n\nNow, when you toggle todos by clicking on them, only the updated component flashes.\n\nThe options that can be set here are:\n\nimmutable={true} — you never use mutable data, so the compiler can do simple referential equality checks to determine if values have changed\nimmutable={false} — the default. Svelte will be more conservative about whether or not mutable objects have changed\naccessors={true} — adds getters and setters for the component's props\naccessors={false} — the default\nnamespace=\"...\" — the namespace where this component will be used, most commonly \"svg\"\ncustomElement=\"...\" — the name to use when compiling this component as a custom element\n\nConsult the API reference for more information on these options.\n\nNext: <svelte:fragment>\n\nEdit this page\nsrc\nApp.svelte\nTodo.svelte\nflash.js\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n<script>\n\timport Todo from './Todo.svelte';\n\n\n\tlet todos = [\n\t\t{ id: 1, done: true, text: 'wash the car' },\n\t\t{ id: 2, done: false, text: 'take the dog for a walk' },\n\t\t{ id: 3, done: false, text: 'mow the lawn' }\n\t];\n\n\n\tfunction toggle(toggled) {\n\t\ttodos = todos.map((todo) => {\n\t\t\tif (todo === toggled) {\n\t\t\t\t// return a new object\n\t\t\t\treturn {\n\t\t\t\t\tid: todo.id,\n\t\t\t\t\ttext: todo.text,\n\t\t\t\t\tdone: !todo.done\n\t\t\t\t};\n\t\t\t}\n\n\n\t\t\t// return the same object\n\t\t\treturn todo;\n\t\t});\n\t}\n</script>\n\n\n<div class=\"centered\">\n\t<h1>todos</h1>\n\n\n\t<ul class=\"todos\">\n\t\t{#each todos as todo (todo.id)}\n\t\t\t<Todo {todo} on:change={() => toggle(todo)} />\n\t\t{/each}\n\t</ul>\n</div>\n\n\ninitialising"
  },
  {
    "title": "Forms / Validation • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/form-validation",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 3\n/\nForms\n/\nValidation\n\nUsers are a mischievous bunch, who will submit all kinds of nonsensical data if given the chance. To prevent them from causing chaos, it's important to validate form data.\n\nThe first line of defense is the browser's built-in form validation, which makes it easy to, for example, mark an <input> as required:\n\nsrc/routes/+page.svelte\n<form method=\"POST\" action=\"?/create\">\n\t<label>\n\t\tadd a todo\n\t\t<input\n\t\t\tname=\"description\"\n\t\t\tautocomplete=\"off\"\n\t\t\trequired\n\t\t/>\n\t</label>\n</form>\n\nTry hitting Enter while the <input> is empty.\n\nThis kind of validation is helpful, but insufficient. Some validation rules (e.g. uniqueness) can't be expressed using <input> attributes, and in any case, if the user is an elite hacker they might simply delete the attributes using the browser's devtools. To guard against these sorts of shenanigans, you should always use server-side validation.\n\nIn src/lib/server/database.js, validate that the description exists and is unique:\n\nsrc/lib/server/database.js\nexport function createTodo(userid, description) {\n\tif (description === '') {\n\t\tthrow new Error('todo must have a description');\n\t}\n\n\tconst todos = db.get(userid);\n\n\tif (todos.find((todo) => todo.description === description)) {\n\t\tthrow new Error('todos must be unique');\n\t}\n\n\ttodos.push({\n\t\tid: crypto.randomUUID(),\n\t\tdescription,\n\t\tdone: false\n\t});\n}\n\nTry submitting a duplicate todo. Yikes! SvelteKit takes us to an unfriendly-looking error page. On the server, we see a 'todos must be unique' error, but SvelteKit hides unexpected error messages from users because they often contain sensitive data.\n\nIt would be much better to stay on the same page and provide an indication of what went wrong so that the user can fix it. To do this, we can use the fail function to return data from the action along with an appropriate HTTP status code:\n\nsrc/routes/+page.server.js\nimport { fail } from '@sveltejs/kit';\nimport * as db from '$lib/server/database.js';\n\nexport function load({ cookies }) {...}\n\nexport const actions = {\n\tcreate: async ({ cookies, request }) => {\n\t\tconst data = await request.formData();\n\n\t\ttry {\n\t\t\tdb.createTodo(cookies.get('userid'), data.get('description'));\n\t\t} catch (error) {\n\t\t\treturn fail(422, {\n\t\t\t\tdescription: data.get('description'),\n\t\t\t\terror: error.message\n\t\t\t});\n\t\t}\n\t}\n\nIn src/routes/+page.svelte, we can access the returned value via the form prop, which is only ever populated after a form submission:\n\nsrc/routes/+page.svelte\n<script>\n\texport let data;\n\texport let form;\n</script>\n\n<div class=\"centered\">\n\t<h1>todos</h1>\n\t\n\t{#if form?.error}\n\t\t<p class=\"error\">{form.error}</p>\n\t{/if}\n\t\n\t<form method=\"POST\" action=\"?/create\">\n\t\t<label>\n\t\t\tadd a todo:\n\t\t\t<input\n\t\t\t\tname=\"description\"\n\t\t\t\tvalue={form?.description ?? ''}\n\t\t\t\tautocomplete=\"off\"\n\t\t\t\trequired\n\t\t\t/>\n\t\t</label>\n\t</form>\n\nYou can also return data from an action without wrapping it in fail — for example to show a 'success!' message when data was saved — and it will be available via the form prop.\n\nNext: Progressive enhancement\n\nEdit this page\nproject\nsrc\nlib\nserver\ndatabase.js\nroutes\n+page.server.js\n+page.svelte\nremove.svg\napp.html\nstatic\nfavicon.png\npackage.json\nsvelte.config.js\nvite.config.js\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n<script>\n\texport let data;\n</script>\n\n\n<div class=\"centered\">\n\t<h1>todos</h1>\n\n\n\t<form method=\"POST\" action=\"?/create\">\n\t\t<label>\n\t\t\tadd a todo:\n\t\t\t<input\n\t\t\t\tname=\"description\"\n\t\t\t\tautocomplete=\"off\"\n\t\t\t/>\n\t\t</label>\n\t</form>\n\n\n\t<ul class=\"todos\">\n\t\t{#each data.todos as todo (todo.id)}\n\t\t\t<li>\n\t\t\t\t<form method=\"POST\" action=\"?/delete\">\n\t\t\t\t\t<input type=\"hidden\" name=\"id\" value={todo.id} />\n\t\t\t\t\t<span>{todo.description}</span>\n\t\t\t\t\t<button aria-label=\"Mark as complete\" />\n\t\t\t\t</form>\n\t\t\t</li>\n\t\t{/each}\n\t</ul>\n</div>\n\n\n<style>\n\t.centered {\n\t\tmax-width: 20em;\n\t\tmargin: 0 auto;\n\t}\n\n\ninitialising"
  },
  {
    "title": "Transitions / Custom JS transitions • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/custom-js-transitions",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 2\n/\nTransitions\n/\nCustom JS transitions\n\nWhile you should generally use CSS for transitions as much as possible, there are some effects that can't be achieved without JavaScript, such as a typewriter effect:\n\nApp.svelte\nfunction typewriter(node, { speed = 1 }) {\n\tconst valid = node.childNodes.length === 1 && node.childNodes[0].nodeType === Node.TEXT_NODE;\n\n\tif (!valid) {\n\t\tthrow new Error(`This transition only works on elements with a single text node child`);\n\t}\n\n\tconst text = node.textContent;\n\tconst duration = text.length / (speed * 0.01);\n\n\treturn {\n\t\tduration,\n\t\ttick: (t) => {\n\t\t\tconst i = Math.trunc(text.length * t);\n\t\t\tnode.textContent = text.slice(0, i);\n\t\t}\n\t};\n}\n\nNext: Transition events\n\nEdit this page\nsrc\nApp.svelte\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n<script>\n\tlet visible = false;\n\n\n\tfunction typewriter(node, { speed = 1 }) {\n\t\tconst valid = node.childNodes.length === 1 && node.childNodes[0].nodeType === Node.TEXT_NODE;\n\n\n\t\tif (!valid) {\n\t\t\tthrow new Error(`This transition only works on elements with a single text node child`);\n\t\t}\n\n\n\t\treturn {};\n\t}\n</script>\n\n\n<label>\n\t<input type=\"checkbox\" bind:checked={visible} />\n\tvisible\n</label>\n\n\n{#if visible}\n\t<p transition:typewriter>\n\t\tThe quick brown fox jumps over the lazy dog\n\t</p>\n{/if}\n\n\ninitialising"
  },
  {
    "title": "Hooks / handleError • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/handleerror",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 4\n/\nHooks\n/\nhandleError\n\nThe handleError hook lets you intercept unexpected errors and trigger some behaviour, like pinging a Slack channel or sending data to an error logging service.\n\nAs you'll recall from an earlier exercise, an error is unexpected if it wasn't created with the error helper from @sveltejs/kit. It generally means something in your app needs fixing. The default behaviour is to log the error:\n\nsrc/hooks.server.js\nexport function handleError({ event, error }) {\n\tconsole.error(error.stack);\n}\n\nIf you navigate to /the-bad-place, you'll see this in action — the error page is shown, and if you open the terminal (using the button to the right of the URL bar), you'll see the message from src/routes/the-bad-place/+page.server.js.\n\nNotice that we're not showing the error message to the user. That's because error messages can include sensitive information that at best will confuse your users, and at worst could benefit evildoers. Instead, the error object available to your application — represented as $page.error in your +error.svelte pages, or %sveltekit.error% in your src/error.html fallback — is just this:\n\n{\n\tmessage: 'Internal Error' // or 'Not Found' for a 404\n}\n\nIn some situations you may want to customise this object. To do so, you can return an object from handleError:\n\nsrc/hooks.server.js\nexport function handleError({ event, error }) {\n\tconsole.error(error.stack);\n\n\treturn {\n\t\tmessage: 'everything is fine',\n\t\tcode: 'JEREMYBEARIMY'\n\t};\n}\n\nYou can now reference properties other than message in a custom error page. Create src/routes/+error.svelte:\n\nsrc/routes/+error.svelte\n<script>\n\timport { page } from '$app/stores';\n</script>\n\n<h1>{$page.status}</h1>\n<p>{$page.error.message}</p>\n<p>error code: {$page.error.code}</p>\n\nNext: Page options\n\nEdit this page\nproject\nsrc\nroutes\nthe-bad-place\n+page.server.js\n+page.svelte\nthe-good-place\n+page.svelte\n+layout.svelte\n+page.svelte\napp.html\nhooks.server.js\nstatic\nfavicon.png\npackage.json\nsvelte.config.js\nvite.config.js\nsolve \n1\n<h1>home</h1>\ninitialising"
  },
  {
    "title": "Errors and redirects / Error pages • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/error-pages",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 3\n/\nErrors and redirects\n/\nError pages\n\nWhen something goes wrong inside a load function, SvelteKit renders an error page.\n\nThe default error page is somewhat bland. We can customize it by creating a src/routes/+error.svelte component:\n\nsrc/routes/+error.svelte\n<script>\n\timport { page } from '$app/stores';\n\timport { emojis } from './emojis.js';\n</script>\n\n<h1>{$page.status} {$page.error.message}</h1>\n<span style=\"font-size: 10em\">\n\t{emojis[$page.status] ?? emojis[500]}\n</span>\n\nNotice that the +error.svelte component is rendered inside the root +layout.svelte. We can create more granular +error.svelte boundaries:\n\nsrc/routes/expected/+error.svelte\n<h1>this error was expected</h1>\n\nThis component will be rendered for /expected, while the root src/routes/+error.svelte page will be rendered for any other errors that occur.\n\nNext: Fallback errors\n\nEdit this page\nproject\nsrc\nroutes\nexpected\n+page.server.js\n+page.svelte\nunexpected\n+page.server.js\n+page.svelte\n+layout.svelte\n+page.svelte\nemojis.js\napp.html\nstatic\nfavicon.png\npackage.json\nsvelte.config.js\nvite.config.js\nsolve \n1\n2\n<h1>home</h1>\n\n\ninitialising"
  },
  {
    "title": "Lifecycle / beforeUpdate and afterUpdate • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/update",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 1\n/\nLifecycle\n/\nbeforeUpdate and afterUpdate\n\nThe beforeUpdate function schedules work to happen immediately before the DOM is updated. afterUpdate is its counterpart, used for running code once the DOM is in sync with your data.\n\nTogether, they're useful for doing things imperatively that are difficult to achieve in a purely state-driven way, like updating the scroll position of an element.\n\nThis Eliza chatbot is annoying to use, because you have to keep scrolling the chat window. Let's fix that.\n\nApp.svelte\nlet div;\nlet autoscroll = false;\n\nbeforeUpdate(() => {\n\tif (div) {\n\t\tconst scrollableDistance = div.scrollHeight - div.offsetHeight;\n\t\tautoscroll = div.scrollTop > scrollableDistance - 20;\n\t}\n});\n\nafterUpdate(() => {\n\tif (autoscroll) {\n\t\tdiv.scrollTo(0, div.scrollHeight);\n\t}\n});\n\nNote that beforeUpdate will first run before the component has mounted, so we need to check for the existence of div before reading its properties.\n\nNext: tick\n\nEdit this page\nsrc\nApp.svelte\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n<script>\n\timport Eliza from 'elizabot';\n\timport {\n\t\tbeforeUpdate,\n\t\tafterUpdate\n\t} from 'svelte';\n\n\n\tlet div;\n\n\n\tbeforeUpdate(() => {\n\t\t// determine whether we should auto-scroll\n\t\t// once the DOM is updated...\n\t});\n\n\n\tafterUpdate(() => {\n\t\t// ...the DOM is now in sync with the data\n\t});\n\n\n\tconst eliza = new Eliza();\n\tconst pause = (ms) => new Promise((fulfil) => setTimeout(fulfil, ms));\n\n\n\tconst typing = { author: 'eliza', text: '...' };\n\n\n\tlet comments = [];\n\n\n\tasync function handleKeydown(event) {\n\t\tif (event.key === 'Enter' && event.target.value) {\n\t\t\tconst comment = {\n\t\t\t\tauthor: 'user',\n\t\t\t\ttext: event.target.value\n\t\t\t};\n\n\n\t\t\tconst reply = {\n\t\t\t\tauthor: 'eliza',\n\t\t\t\ttext: eliza.transform(comment.text)\n\t\t\t};\ninitialising"
  },
  {
    "title": "Events / Event modifiers • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/event-modifiers",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 1\n/\nEvents\n/\nEvent modifiers\n\nDOM event handlers can have modifiers that alter their behaviour. For example, a handler with a once modifier will only run a single time:\n\nApp.svelte\n<button on:click|once={() => alert('clicked')}>\n\tClick me\n</button>\n\nThe full list of modifiers:\n\npreventDefault — calls event.preventDefault() before running the handler. Useful for client-side form handling, for example.\nstopPropagation — calls event.stopPropagation(), preventing the event reaching the next element\npassive — improves scrolling performance on touch/wheel events (Svelte will add it automatically where it's safe to do so)\nnonpassive — explicitly set passive: false\ncapture — fires the handler during the capture phase instead of the bubbling phase\nonce — remove the handler after the first time it runs\nself — only trigger handler if event.target is the element itself\ntrusted — only trigger handler if event.isTrusted is true, meaning the event was triggered by a user action rather than because some JavaScript called element.dispatchEvent(...)\n\nYou can chain modifiers together, e.g. on:click|once|capture={...}.\n\nNext: Component events\n\nEdit this page\nsrc\nApp.svelte\nsolve \n1\n2\n3\n4\n⌄\n<button on:click={() => alert('clicked')}>\n\tClick me\n</button>\n\n\ninitialising"
  },
  {
    "title": "Logic / Keyed each blocks • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/keyed-each-blocks",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nTutorial\nSvelte\nSvelteKit\nPart 1\n/\nLogic\n/\nKeyed each blocks\n\nBy default, when you modify the value of an each block, it will add and remove DOM nodes at the end of the block, and update any values that have changed. That might not be what you want.\n\nIt's easier to show why than to explain. The <Thing> component sets the emoji as a constant on initialization, but the name is passed in via a prop.\n\nClick the 'Remove first thing' button a few times, and notice what happens:\n\nIt removes the last component.\nIt then updates the name value in the remaining DOM nodes, but not the emoji, which is fixed when each <Thing> is created.\n\nInstead, we'd like to remove only the first <Thing> component and its DOM node, and leave the others unaffected.\n\nTo do that, we specify a unique identifier (or \"key\") for each iteration of the each block:\n\nApp.svelte\n{#each things as thing (thing.id)}\n\t<Thing name={thing.name}/>\n{/each}\n\nHere, (thing.id) is the key, which tells Svelte how to figure out what to update when the values (name in this example) change.\n\nYou can use any object as the key, as Svelte uses a Map internally — in other words you could do (thing) instead of (thing.id). Using a string or number is generally safer, however, since it means identity persists without referential equality, for example when updating with fresh data from an API server.\n\nNext: Await blocks\n\nEdit this page\nsrc\nApp.svelte\nThing.svelte\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n<script>\n\timport Thing from './Thing.svelte';\n \n\tlet things = [\n\t\t{ id: 1, name: 'apple' },\n\t\t{ id: 2, name: 'banana' },\n\t\t{ id: 3, name: 'carrot' },\n\t\t{ id: 4, name: 'doughnut' },\n\t\t{ id: 5, name: 'egg' }\n\t];\n \n\tfunction handleClick() {\n\t\tthings = things.slice(1);\n\t}\n</script>\n \n<button on:click={handleClick}>\n\tRemove first thing\n</button>\n \n{#each things as thing}\n\t<Thing name={thing.name} />\n{/each}\n \ninitialising"
  },
  {
    "title": "Reactivity / Updating arrays and objects • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/updating-arrays-and-objects",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 1\n/\nReactivity\n/\nUpdating arrays and objects\n\nBecause Svelte's reactivity is triggered by assignments, using array methods like push and splice won't automatically cause updates. For example, clicking the 'Add a number' button doesn't currently do anything, even though we're calling numbers.push(...) inside addNumber.\n\nOne way to fix that is to add an assignment that would otherwise be redundant:\n\nApp.svelte\nfunction addNumber() {\n\tnumbers.push(numbers.length + 1);\n\tnumbers = numbers;\n}\n\nBut there's a more idiomatic solution:\n\nApp.svelte\nfunction addNumber() {\n\tnumbers = [...numbers, numbers.length + 1];\n}\n\nYou can use similar patterns to replace pop, shift, unshift and splice.\n\nAssignments to properties of arrays and objects — e.g. obj.foo += 1 or array[i] = x — work the same way as assignments to the values themselves.\n\nApp.svelte\nfunction addNumber() {\n\tnumbers[numbers.length] = numbers.length + 1;\n}\n\nA simple rule of thumb: the name of the updated variable must appear on the left hand side of the assignment. For example this...\n\nconst obj = { foo: { bar: 1 } };\nconst foo = obj.foo;\nfoo.bar = 2;\n\n...won't trigger reactivity on obj.foo.bar, unless you follow it up with obj = obj.\n\nNext: Props\n\nEdit this page\nsrc\nApp.svelte\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n⌄\n⌄\n⌄\n<script>\n\tlet numbers = [1, 2, 3, 4];\n\n\n\tfunction addNumber() {\n\t\tnumbers.push(numbers.length + 1);\n\t}\n\n\n\t$: sum = numbers.reduce((total, currentNumber) => total + currentNumber, 0);\n</script>\n\n\n<p>{numbers.join(' + ')} = {sum}</p>\n\n\n<button on:click={addNumber}>\n\tAdd a number\n</button>\n\n\ninitialising"
  },
  {
    "title": "API routes / Other handlers • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/other-handlers",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 3\n/\nAPI routes\n/\nOther handlers\n\nSimilarly, we can add handlers for other HTTP verbs. Add a /todo/[id] route by creating a src/routes/todo/[id]/+server.js file with PUT and DELETE handlers for toggling and removing todos, using the toggleTodo and deleteTodo functions in src/lib/server/database.js:\n\nsrc/routes/todo/[id]/+server.js\nimport * as database from '$lib/server/database.js';\n\nexport async function PUT({ params, request, cookies }) {\n\tconst { done } = await request.json();\n\tconst userid = cookies.get('userid');\n\n\tawait database.toggleTodo({ userid, id: params.id, done });\n\treturn new Response(null, { status: 204 });\n}\n\nexport async function DELETE({ params, cookies }) {\n\tconst userid = cookies.get('userid');\n\n\tawait database.deleteTodo({ userid, id: params.id });\n\treturn new Response(null, { status: 204 });\n}\n\nSince we don't need to return any actual data to the browser, we're returning an empty Response with a 204 No Content status.\n\nWe can now interact with this endpoint inside our event handlers:\n\nsrc/routes/+page.svelte\n<label>\n\t<input\n\t\ttype=\"checkbox\"\n\t\tchecked={todo.done}\n\t\ton:change={async (e) => {\n\t\t\tconst done = e.currentTarget.checked;\n\n\t\t\tawait fetch(`/todo/${todo.id}`, {\n\t\t\t\tmethod: 'PUT',\n\t\t\t\tbody: JSON.stringify({ done }),\n\t\t\t\theaders: {\n\t\t\t\t\t'Content-Type': 'application/json'\n\t\t\t\t}\n\t\t\t});\n\t\t}}\n\t/>\n\t<span>{todo.description}</span>\n\t<button\n\t\taria-label=\"Mark as complete\"\n\t\ton:click={async (e) => {\n\t\t\tawait fetch(`/todo/${todo.id}`, {\n\t\t\t\tmethod: 'DELETE'\n\t\t\t});\n\n\t\t\tdata.todos = data.todos.filter((t) => t !== todo);\n\t\t}}\n\t/>\n</label>\n\nNext: Stores\n\nEdit this page\nproject\nsrc\nlib\nserver\ndatabase.js\nroutes\ntodo\n+server.js\n+page.server.js\n+page.svelte\nremove.svg\napp.html\nstatic\nfavicon.png\npackage.json\nsvelte.config.js\nvite.config.js\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n⌄\n⌄\n⌄\n<script>\n\texport let data;\n</script>\n\n\n<div class=\"centered\">\n\t<h1>todos</h1>\n\n\n\t<label>\n\t\tadd a todo:\n\t\t<input\n\t\t\ttype=\"text\"\n\t\t\tautocomplete=\"off\"\n\t\t\ton:keydown={async (e) => {\n\t\t\t\tif (e.key !== 'Enter') return;\n\n\n\t\t\t\tconst input = e.currentTarget;\n\t\t\t\tconst description = input.value;\n\t\t\t\t\n\t\t\t\tconst response = await fetch('/todo', {\n\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\tbody: JSON.stringify({ description }),\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'Content-Type': 'application/json'\n\t\t\t\t\t}\n\t\t\t\t});\n\n\n\t\t\t\tconst { id } = await response.json();\n\n\n\t\t\t\tdata.todos = [...data.todos, {\n\t\t\t\t\tid,\n\t\t\t\t\tdescription\n\t\t\t\t}];\n\n\n\t\t\t\tinput.value = '';\n\t\t\t}}\n\t\t/>\ninitialising"
  },
  {
    "title": "Forms / Progressive enhancement • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/progressive-enhancement",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nTutorial\nSvelte\nSvelteKit\nPart 3\n/\nForms\n/\nProgressive enhancement\n\nBecause we're using <form>, our app works even if the user doesn't have JavaScript (which happens more often than you probably think). That's great, because it means our app is resilient.\n\nMost of the time, users do have JavaScript. In those cases, we can progressively enhance the experience, the same way SvelteKit progressively enhances <a> elements by using client-side routing.\n\nImport the enhance function from $app/forms...\n\nsrc/routes/+page.svelte\n<script>\n\timport { enhance } from '$app/forms';\n\n\texport let data;\n\texport let form;\n</script>\n\n...and add the use:enhance directive to the <form> elements:\n\nsrc/routes/+page.svelte\n<form method=\"POST\" action=\"?/create\" use:enhance>\nsrc/routes/+page.svelte\n<form method=\"POST\" action=\"?/delete\" use:enhance>\n\nAnd that's all it takes! Now, when JavaScript is enabled, use:enhance will emulate the browser-native behaviour except for the full-page reloads. It will:\n\nupdate the form prop\ninvalidate all data on a successful response, causing load functions to re-run\nnavigate to the new page on a redirect response\nrender the nearest error page if an error occurs\n\nNow that we're updating the page rather than reloading it, we can get fancy with things like transitions:\n\nsrc/routes/+page.svelte\n<script>\n\timport { fly, slide } from 'svelte/transition';\n\timport { enhance } from '$app/forms';\n\n\texport let data;\n\texport let form;\n</script>\nsrc/routes/+page.svelte\n<li in:fly={{ y: 20 }} out:slide>...</li>\n\nNext: Customizing use:enhance\n\nEdit this page\nproject\nsrc\nlib\nserver\ndatabase.js\nroutes\n+page.server.js\n+page.svelte\nremove.svg\napp.html\nstatic\nfavicon.png\npackage.json\nsvelte.config.js\nvite.config.js\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n<script>\n\texport let data;\n\texport let form;\n</script>\n \n<div class=\"centered\">\n\t<h1>todos</h1>\n \n\t{#if form?.error}\n\t\t<p class=\"error\">{form.error}</p>\n\t{/if}\n \n\t<form method=\"POST\" action=\"?/create\">\n\t\t<label>\n\t\t\tadd a todo:\n\t\t\t<input\n\t\t\t\tname=\"description\"\n\t\t\t\tvalue={form?.description ?? ''}\n\t\t\t\tautocomplete=\"off\"\n\t\t\t\trequired\n\t\t\t/>\n\t\t</label>\n\t</form>\n \n\t<ul class=\"todos\">\n\t\t{#each data.todos as todo (todo.id)}\n\t\t\t<li>\n\t\t\t\t<form method=\"POST\" action=\"?/delete\">\n\t\t\t\t\t<input type=\"hidden\" name=\"id\" value={todo.id} />\n\t\t\t\t\t<span>{todo.description}</span>\n\t\t\t\t\t<button aria-label=\"Mark as complete\" />\n\t\t\t\t</form>\n\t\t\t</li>\n\t\t{/each}\n\t</ul>\n</div>\n \n<style>\n\t.centered {\n\t\tmax-width: 20em;\n\t\tmargin: 0 auto;\n\t}\n \n\tlabel {\n\t\twidth: 100%;\n\t}\n \n\tinput {\n\t\tflex: 1;\n\t}\n \n\tspan {\n\t\tflex: 1;\n\t}\n \n\tbutton {\n\t\tborder: none;\n\t\tbackground: url(./remove.svg) no-repeat 50% 50%;\n\t\tbackground-size: 1rem 1rem;\n\t\tcursor: pointer;\n\t\theight: 100%;\n\t\taspect-ratio: 1;\n\t\topacity: 0.5;\n\t\ttransition: opacity 0.2s;\n\t}\n \n\tbutton:hover {\n\t\topacity: 1;\n\t}\n \n\t.saving {\n\t\topacity: 0.5;\n\t}\n</style>\n \ninitialising"
  },
  {
    "title": "Hooks / handleFetch • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/handlefetch",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 4\n/\nHooks\n/\nhandleFetch\n\nThe event object has a fetch method that behaves like the standard Fetch API, but with superpowers:\n\nit can be used to make credentialed requests on the server, as it inherits the cookie and authorization headers from the incoming request\nit can make relative requests on the server (ordinarily, fetch requires a URL with an origin when used in a server context)\ninternal requests (e.g. for +server.js routes) go directly to the handler function when running on the server, without the overhead of an HTTP call\n\nIts behaviour can be modified with the handleFetch hook, which by default looks like this:\n\nsrc/hooks.server.js\nexport async function handleFetch({ event, request, fetch }) {\n\treturn await fetch(request);\n}\n\nFor example, we could respond to requests for src/routes/a/+server.js with responses from src/routes/b/+server.js instead:\n\nsrc/hooks.server.js\nexport async function handleFetch({ event, request, fetch }) {\n\tconst url = new URL(request.url);\n\tif (url.pathname === '/a') {\n\t\treturn await fetch('/b');\n\t}\n\n\treturn await fetch(request);\n}\n\nLater, when we cover universal load functions, we'll see that event.fetch can also be called from the browser. In that scenario, handleFetch is useful if you have requests to a public URL like https://api.yourapp.com from the browser, that should be redirected to an internal URL (bypassing whatever proxies and load balancers sit between the API server and the public internet) when running on the server.\n\nNext: handleError\n\nEdit this page\nproject\nsrc\nroutes\na\n+server.js\nb\n+server.js\n+page.server.js\n+page.svelte\napp.html\nhooks.server.js\nstatic\nfavicon.png\npackage.json\nsvelte.config.js\nvite.config.js\nsolve \n1\n2\n3\n4\n5\n⌄\n<script>\n\texport let data;\n</script>\n\n\n<h1>{data.message}</h1>\ninitialising"
  },
  {
    "title": "Errors and redirects / Fallback errors • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/fallback-errors",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 3\n/\nErrors and redirects\n/\nFallback errors\n\nIf things go really wrong — an error occurs while loading the root layout data, or while rendering the error page — SvelteKit will fall back to a static error page.\n\nAdd a new src/routes/+layout.server.js file to see this in action:\n\nsrc/routes/+layout.server.js\nexport function load() {\n\tthrow new Error('yikes');\n}\n\nYou can customise the fallback error page. Create a src/error.html file:\n\nsrc/error.html\n<h1>Game over</h1>\n<p>Code %sveltekit.status%</p>\n<p>%sveltekit.error.message%</p>\n\nThis file can include the following:\n\n%sveltekit.status% — the HTTP status code\n%sveltekit.error.message% — the error message\n\nNext: Redirects\n\nEdit this page\nproject\nsrc\nroutes\nexpected\n+error.svelte\n+page.server.js\n+page.svelte\nunexpected\n+page.server.js\n+page.svelte\n+error.svelte\n+layout.svelte\n+page.svelte\nemojis.js\napp.html\nstatic\nfavicon.png\npackage.json\nsvelte.config.js\nvite.config.js\nsolve \n1\n2\n<h1>home</h1>\n\n\ninitialising"
  },
  {
    "title": "Lifecycle / tick • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/tick",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 1\n/\nLifecycle\n/\ntick\n\nThe tick function is unlike other lifecycle functions in that you can call it any time, not just when the component first initialises. It returns a promise that resolves as soon as any pending state changes have been applied to the DOM (or immediately, if there are no pending state changes).\n\nWhen you update component state in Svelte, it doesn't update the DOM immediately. Instead, it waits until the next microtask to see if there are any other changes that need to be applied, including in other components. Doing so avoids unnecessary work and allows the browser to batch things more effectively.\n\nYou can see that behaviour in this example. Select a range of text and hit the tab key. Because the <textarea> value changes, the current selection is cleared and the cursor jumps, annoyingly, to the end. We can fix this by importing tick...\n\nApp.svelte\nimport { tick } from 'svelte';\n\nlet text = `Select some text and hit the tab key to toggle uppercase`;\n\n...and running it immediately before we set this.selectionStart and this.selectionEnd at the end of handleKeydown:\n\nApp.svelte\nawait tick();\nthis.selectionStart = selectionStart;\nthis.selectionEnd = selectionEnd;\n\nNext: Stores\n\nEdit this page\nsrc\nApp.svelte\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n⌄\n⌄\n⌄\n<script>\n\tlet text = `Select some text and hit the tab key to toggle uppercase`;\n\n\n\tasync function handleKeydown(event) {\n\t\tif (event.key !== 'Tab') return;\n\n\n\t\tevent.preventDefault();\n\n\n\t\tconst { selectionStart, selectionEnd, value } = this;\n\t\tconst selection = value.slice(selectionStart, selectionEnd);\n\n\n\t\tconst replacement = /[a-z]/.test(selection)\n\t\t\t? selection.toUpperCase()\n\t\t\t: selection.toLowerCase();\n\n\n\t\ttext =\n\t\t\tvalue.slice(0, selectionStart) +\n\t\t\treplacement +\n\t\t\tvalue.slice(selectionEnd);\n\n\n\t\t// this has no effect, because the DOM hasn't updated yet\n\t\tthis.selectionStart = selectionStart;\n\t\tthis.selectionEnd = selectionEnd;\n\t}\n</script>\n\n\n<textarea\n\tvalue={text}\n\ton:keydown={handleKeydown}\n/>\n\n\n<style>\n\ttextarea {\n\t\twidth: 100%;\n\t\theight: 100%;\n\t\tresize: none;\ninitialising"
  },
  {
    "title": "Events / Inline handlers • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/inline-handlers",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 1\n/\nEvents\n/\nInline handlers\n\nYou can also declare event handlers inline:\n\nApp.svelte\n<script>\n\tlet m = { x: 0, y: 0 };\n\n\tfunction handleMove(event) {\n\t\tm.x = event.clientX;\n\t\tm.y = event.clientY;\n\t}\n</script>\n\n<div\n\ton:pointermove={(e) => {\n\t\tm = { x: e.clientX, y: e.clientY };\n\t}}\n>\n\tThe pointer is at {m.x} x {m.y}\n</div>\n\nIn some frameworks you may see recommendations to avoid inline event handlers for performance reasons, particularly inside loops. That advice doesn't apply to Svelte — the compiler will always do the right thing, whichever form you choose.\n\nNext: Event modifiers\n\nEdit this page\nsrc\nApp.svelte\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n⌄\n⌄\n⌄\n⌄\n⌄\n<script>\n\tlet m = { x: 0, y: 0 };\n\n\n\tfunction handleMove(event) {\n\t\tm.x = event.clientX;\n\t\tm.y = event.clientY;\n\t}\n</script>\n\n\n<div on:pointermove={handleMove}>\n\tThe pointer is at {m.x} x {m.y}\n</div>\n\n\n<style>\n\tdiv {\n\t\tposition: fixed;\n\t\tleft: 0;\n\t\ttop: 0;\n\t\twidth: 100%;\n\t\theight: 100%;\n\t\tpadding: 1rem;\n\t}\n</style>\n\n\ninitialising"
  },
  {
    "title": "Logic / Await blocks • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/await-blocks",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 1\n/\nLogic\n/\nAwait blocks\n\nMost web applications have to deal with asynchronous data at some point. Svelte makes it easy to await the value of promises directly in your markup:\n\nApp.svelte\n{#await promise}\n\t<p>...waiting</p>\n{:then number}\n\t<p>The number is {number}</p>\n{:catch error}\n\t<p style=\"color: red\">{error.message}</p>\n{/await}\n\nOnly the most recent promise is considered, meaning you don't need to worry about race conditions.\n\nIf you know that your promise can't reject, you can omit the catch block. You can also omit the first block if you don't want to show anything until the promise resolves:\n\n{#await promise then number}\n\t<p>The number is {number}</p>\n{/await}\n\nNext: Events\n\nEdit this page\nsrc\nApp.svelte\nutils.js\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n⌄\n⌄\n⌄\n<script>\n\timport { getRandomNumber } from './utils.js';\n\n\n\tlet promise = getRandomNumber();\n\n\n\tfunction handleClick() {\n\t\tpromise = getRandomNumber();\n\t}\n</script>\n\n\n<button on:click={handleClick}>\n\tgenerate random number\n</button>\n\n\n<p>...waiting</p>\n\n\ninitialising"
  },
  {
    "title": "Reactivity / Statements • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/reactive-statements",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 1\n/\nReactivity\n/\nStatements\n\nWe're not limited to declaring reactive values — we can also run arbitrary statements reactively. For example, we can log the value of count whenever it changes:\n\nApp.svelte\nlet count = 0;\n\n$: console.log(`the count is ${count}`);\n\nYou can easily group statements together with a block:\n\nApp.svelte\n$: {\n\tconsole.log(`the count is ${count}`);\n\tconsole.log(`this will also be logged whenever count changes`);\n}\n\nYou can even put the $: in front of things like if blocks:\n\nApp.svelte\n$: if (count >= 10) {\n\talert('count is dangerously high!');\n\tcount = 0;\n}\n\nNext: Updating arrays and objects\n\nEdit this page\nsrc\nApp.svelte\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n⌄\n⌄\n⌄\n<script>\n\tlet count = 0;\n\n\n\tfunction handleClick() {\n\t\tcount += 1;\n\t}\n</script>\n\n\n<button on:click={handleClick}>\n\tClicked {count}\n\t{count === 1 ? 'time' : 'times'}\n</button>\n\n\ninitialising"
  },
  {
    "title": "API routes / POST handlers • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/post-handlers",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 3\n/\nAPI routes\n/\nPOST handlers\n\nYou can also add handlers that mutate data, such as POST. In most cases, you should use form actions instead — you'll end up writing less code, and it'll work without JavaScript, making it more resilient.\n\nInside the keydown event handler of the 'add a todo' <input>, let's post some data to the server:\n\nsrc/routes/+page.svelte\n<input\n\ttype=\"text\"\n\tautocomplete=\"off\"\n\ton:keydown={async (e) => {\n\t\tif (e.key !== 'Enter') return;\n\n\t\tconst input = e.currentTarget;\n\t\tconst description = input.value;\n\n\t\tconst response = await fetch('/todo', {\n\t\t\tmethod: 'POST',\n\t\t\tbody: JSON.stringify({ description }),\n\t\t\theaders: {\n\t\t\t\t'Content-Type': 'application/json'\n\t\t\t}\n\t\t});\n\n\t\tinput.value = '';\n\t}}\n/>\n\nHere, we're posting some JSON to the /todo API route — using a userid from the user's cookies — and receiving the id of the newly created todo in response.\n\nCreate the /todo route by adding a src/routes/todo/+server.js file with a POST handler that calls createTodo in src/lib/server/database.js:\n\nsrc/routes/todo/+server.js\nimport { json } from '@sveltejs/kit';\nimport * as database from '$lib/server/database.js';\n\nexport async function POST({ request, cookies }) {\n\tconst { description } = await request.json();\n\n\tconst userid = cookies.get('userid');\n\tconst { id } = await database.createTodo({ userid, description });\n\n\treturn json({ id }, { status: 201 });\n}\n\nAs with load functions and form actions, the request is a standard Request object; await request.json() returns the data that we posted from the event handler.\n\nWe're returning a response with a 201 Created status and the id of the newly generated todo in our database. Back in the event handler, we can use this to update the page:\n\nsrc/routes/+page.svelte\n<input\n\ttype=\"text\"\n\tautocomplete=\"off\"\n\ton:keydown={async (e) => {\n\t\tif (e.key !== 'Enter') return;\n\n\t\tconst input = e.currentTarget;\n\t\tconst description = input.value;\n\n\t\tconst response = await fetch('/todo', {\n\t\t\tmethod: 'POST',\n\t\t\tbody: JSON.stringify({ description }),\n\t\t\theaders: {\n\t\t\t\t'Content-Type': 'application/json'\n\t\t\t}\n\t\t});\n\n\t\tconst { id } = await response.json();\n\n\t\tdata.todos = [...data.todos, {\n\t\t\tid,\n\t\t\tdescription\n\t\t}];\n\n\t\tinput.value = '';\n\t}}\n/>\n\nYou should only mutate data in such a way that you'd get the same result by reloading the page.\n\nNext: Other handlers\n\nEdit this page\nproject\nsrc\nlib\nserver\ndatabase.js\nroutes\n+page.server.js\n+page.svelte\nremove.svg\napp.html\nstatic\nfavicon.png\npackage.json\nsvelte.config.js\nvite.config.js\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n<script>\n\texport let data;\n</script>\n\n\n<div class=\"centered\">\n\t<h1>todos</h1>\n\n\n\t<label>\n\t\tadd a todo:\n\t\t<input\n\t\t\ttype=\"text\"\n\t\t\tautocomplete=\"off\"\n\t\t\ton:keydown={async (e) => {\n\t\t\t\tif (e.key !== 'Enter') return;\n\n\n\t\t\t\tconst input = e.currentTarget;\n\t\t\t\tconst description = input.value;\n\t\t\t\t\n\t\t\t\t// TODO handle submit\n\n\n\t\t\t\tinput.value = '';\n\t\t\t}}\n\t\t/>\n\t</label>\n\n\n\t<ul class=\"todos\">\n\t\t{#each data.todos as todo (todo.id)}\n\t\t\t<li>\n\t\t\t\t<label>\n\t\t\t\t\t<input\n\t\t\t\t\t\ttype=\"checkbox\"\n\t\t\t\t\t\tchecked={todo.done}\n\t\t\t\t\t\ton:change={async (e) => {\n\t\t\t\t\t\t\tconst done = e.currentTarget.checked;\n\n\n\t\t\t\t\t\t\t// TODO handle change\ninitialising"
  },
  {
    "title": "Forms / Customizing use:enhance • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/customizing-use-enhance",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 3\n/\nForms\n/\nCustomizing use:enhance\n\nWith use:enhance, we can go further than just emulating the browser's native behaviour. By providing a callback, we can add things like pending states and optimistic UI. Let's simulate a slow network by adding an artificial delay to our two actions:\n\nsrc/routes/+page.server.js\nexport const actions = {\n\tcreate: async ({ cookies, request }) => {\n\t\tawait new Promise((fulfil) => setTimeout(fulfil, 1000));\n\t\t...\n\t},\n\n\tdelete: async ({ cookies, request }) => {\n\t\tawait new Promise((fulfil) => setTimeout(fulfil, 1000));\n\t\t...\n\t}\n};\n\nWhen we create or delete items, it now takes a full second before the UI updates, leaving the user wondering if they messed up somehow. To solve that, add some local state...\n\nsrc/routes/+page.svelte\n<script>\n\timport { fly, slide } from 'svelte/transition';\n\timport { enhance } from '$app/forms';\n\n\texport let data;\n\texport let form;\n\n\tlet creating = false;\n\tlet deleting = [];\n</script>\n\n...and toggle creating inside the first use:enhance:\n\nsrc/routes/+page.svelte\n<form\n\tmethod=\"POST\"\n\taction=\"?/create\"\n\tuse:enhance={() => {\n\t\tcreating = true;\n\n\t\treturn async ({ update }) => {\n\t\t\tawait update();\n\t\t\tcreating = false;\n\t\t};\n\t}}\n>\n\t<label>\n\t\tadd a todo:\n\t\t<input\n\t\t\tdisabled={creating}\n\t\t\tname=\"description\"\n\t\t\tvalue={form?.description ?? ''}\n\t\t\tautocomplete=\"off\"\n\t\t\trequired\n\t\t/>\n\t</label>\n</form>\n\nWe can then show a message while we're saving data:\n\nsrc/routes/+page.svelte\n<ul class=\"todos\">\n\t<!-- ... -->\n</ul>\n\n{#if creating}\n\t<span class=\"saving\">saving...</span>\n{/if}\n\nIn the case of deletions, we don't really need to wait for the server to validate anything — we can just update the UI immediately:\n\nsrc/routes/+page.svelte\n<ul class=\"todos\">\n\t{#each data.todos.filter((todo) => !deleting.includes(todo.id)) as todo (todo.id)}\n\t\t<li in:fly={{ y: 20 }} out:slide>\n\t\t\t<form\n\t\t\t\tmethod=\"POST\"\n\t\t\t\taction=\"?/delete\"\n\t\t\t\tuse:enhance={() => {\n\t\t\t\t\tdeleting = [...deleting, todo.id];\n\t\t\t\t\treturn async ({ update }) => {\n\t\t\t\t\t\tawait update();\n\t\t\t\t\t\tdeleting = deleting.filter((id) => id !== todo.id);\n\t\t\t\t\t};\n\t\t\t\t}}\n\t\t\t>\n\t\t\t\t<input type=\"hidden\" name=\"id\" value={todo.id} />\n\t\t\t\t<button aria-label=\"Mark as complete\">✔</button>\n\n\t\t\t\t{todo.description}\n\t\t\t</form>\n\t\t</li>\n\t{/each}\n</ul>\n\nuse:enhance is very customizable — you can cancel() submissions, handle redirects, control whether the form is reset, and so on. See the docs for full details.\n\nNext: API routes\n\nEdit this page\nproject\nsrc\nlib\nserver\ndatabase.js\nroutes\n+page.server.js\n+page.svelte\nremove.svg\napp.html\nstatic\nfavicon.png\npackage.json\nsvelte.config.js\nvite.config.js\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n<script>\n\timport { fly, slide } from 'svelte/transition';\n\timport { enhance } from '$app/forms';\n\n\n\texport let data;\n\texport let form;\n</script>\n\n\n<div class=\"centered\">\n\t<h1>todos</h1>\n\n\n\t{#if form?.error}\n\t\t<p class=\"error\">{form.error}</p>\n\t{/if}\n\n\n\t<form method=\"POST\" action=\"?/create\" use:enhance>\n\t\t<label>\n\t\t\tadd a todo:\n\t\t\t<input\n\t\t\t\tname=\"description\"\n\t\t\t\tvalue={form?.description ?? ''}\n\t\t\t\tautocomplete=\"off\"\n\t\t\t\trequired\n\t\t\t/>\n\t\t</label>\n\t</form>\n\n\n\t<ul class=\"todos\">\n\t\t{#each data.todos as todo (todo.id)}\n\t\t\t<li in:fly={{ y: 20 }} out:slide>\n\t\t\t\t<form method=\"POST\" action=\"?/delete\" use:enhance>\n\t\t\t\t\t<input type=\"hidden\" name=\"id\" value={todo.id} />\n\t\t\t\t\t<span>{todo.description}</span>\n\t\t\t\t\t<button aria-label=\"Mark as complete\" />\n\t\t\t\t</form>\n\t\t\t</li>\ninitialising"
  },
  {
    "title": "Hooks / The RequestEvent object • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/event",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 4\n/\nHooks\n/\nThe RequestEvent object\n\nThe event object passed into handle is the same object — an instance of a RequestEvent — that is passed into API routes in +server.js files, form actions in +page.server.js files, and load functions in +page.server.js and +layout.server.js.\n\nIt contains a number of useful properties and methods, some of which we've already encountered:\n\ncookies — the cookies API\nfetch — the standard Fetch API, with additional powers\ngetClientAddress() — a function to get the client's IP address\nisDataRequest — true if the browser is requesting data for a page during client-side navigation, false if a page/route is being requested directly\nlocals — a place to put arbitrary data\nparams — the route parameters\nrequest — the Request object\nroute — an object with an id property representing the route that was matched\nsetHeaders(...) — a function for setting HTTP headers on the response\nurl — a URL object representing the current request\n\nA useful pattern is to add some data to event.locals in handle so that it can be read in subsequent load functions:\n\nsrc/hooks.server.js\nexport async function handle({ event, resolve }) {\n\tevent.locals.answer = 42;\n\treturn await resolve(event);\n}\nsrc/routes/+page.server.js\nexport function load(event) {\n\treturn {\n\t\tmessage: `the answer is ${event.locals.answer}`\n\t};\n}\n\nNext: handleFetch\n\nEdit this page\nproject\nsrc\nroutes\n+page.server.js\n+page.svelte\napp.html\nhooks.server.js\nstatic\nfavicon.png\npackage.json\nsvelte.config.js\nvite.config.js\nsolve \n1\n2\n3\n4\n5\n⌄\n<script>\n\texport let data;\n</script>\n\n\n<h1>{data.message}</h1>\nbooting webcontainer"
  },
  {
    "title": "Errors and redirects / Redirects • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/redirects",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 3\n/\nErrors and redirects\n/\nRedirects\n\nWe can also use the throw mechanism to redirect from one page to another.\n\nCreate a new load function in src/routes/a/+page.server.js:\n\nsrc/routes/a/+page.server.js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load() {\n\tthrow redirect(307, '/b');\n}\n\nNavigating to /a will now take us straight to /b.\n\nYou can throw redirect(...) inside load functions, form actions, API routes and the handle hook, which we'll discuss in a later chapter.\n\nThe most common status codes you'll use:\n\n303 — for form actions, following a successful submission\n307 — for temporary redirects\n308 — for permanent redirects\n\nNext: Advanced SvelteKit\n\nEdit this page\nproject\nsrc\nroutes\na\n+page.svelte\nb\n+page.svelte\n+layout.svelte\n+page.svelte\napp.html\nstatic\nfavicon.png\npackage.json\nsvelte.config.js\nvite.config.js\nsolve \n1\n2\n<p>home</p>\n\n\nbooting webcontainer"
  },
  {
    "title": "Stores / Writable stores • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/writable-stores",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 1\n/\nStores\n/\nWritable stores\n\nNot all application state belongs inside your application's component hierarchy. Sometimes, you'll have values that need to be accessed by multiple unrelated components, or by a regular JavaScript module.\n\nIn Svelte, we do this with stores. A store is simply an object with a subscribe method that allows interested parties to be notified whenever the store value changes. In App.svelte, count is a store, and we're setting count_value in the count.subscribe callback.\n\nOpen stores.js to see the definition of count. It's a writable store, which means it has set and update methods in addition to subscribe.\n\nNow, in Incrementer.svelte, wire up the + button:\n\nIncrementer.svelte\nfunction increment() {\n\tcount.update((n) => n + 1);\n}\n\nClicking the + button should now update the count. Do the inverse for Decrementer.svelte.\n\nFinally, in Resetter.svelte, implement reset:\n\nResetter.svelte\nfunction reset() {\n\tcount.set(0);\n}\n\nNext: Auto-subscriptions\n\nEdit this page\nsrc\nApp.svelte\nDecrementer.svelte\nIncrementer.svelte\nResetter.svelte\nstores.js\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n⌄\n⌄\n<script>\n\timport { count } from './stores.js';\n\timport Incrementer from './Incrementer.svelte';\n\timport Decrementer from './Decrementer.svelte';\n\timport Resetter from './Resetter.svelte';\n\n\n\tlet count_value;\n\n\n\tcount.subscribe((value) => {\n\t\tcount_value = value;\n\t});\n</script>\n\n\n<h1>The count is {count_value}</h1>\n\n\n<Incrementer />\n<Decrementer />\n<Resetter />\n\n\ninitialising"
  },
  {
    "title": "Events / DOM events • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/dom-events",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 1\n/\nEvents\n/\nDOM events\n\nAs we've briefly seen already, you can listen to any DOM event on an element (such as click or pointermove) with the on: directive:\n\nApp.svelte\n<div on:pointermove={handleMove}>\n\tThe pointer is at {m.x} x {m.y}\n</div>\n\nNext: Inline handlers\n\nEdit this page\nsrc\nApp.svelte\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n⌄\n⌄\n⌄\n⌄\n⌄\n<script>\n\tlet m = { x: 0, y: 0 };\n\n\n\tfunction handleMove(event) {\n\t\tm.x = event.clientX;\n\t\tm.y = event.clientY;\n\t}\n</script>\n\n\n<div>\n\tThe pointer is at {m.x} x {m.y}\n</div>\n\n\n<style>\n\tdiv {\n\t\tposition: fixed;\n\t\tleft: 0;\n\t\ttop: 0;\n\t\twidth: 100%;\n\t\theight: 100%;\n\t\tpadding: 1rem;\n\t}\n</style>\n\n\ninitialising"
  },
  {
    "title": "Reactivity / Declarations • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/reactive-declarations",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 1\n/\nReactivity\n/\nDeclarations\n\nSvelte automatically updates the DOM when your component's state changes. Often, some parts of a component's state need to be computed from other parts (such as a fullname derived from a firstname and a lastname), and recomputed whenever they change.\n\nFor these, we have reactive declarations. They look like this:\n\nApp.svelte\nlet count = 0;\n$: doubled = count * 2;\n\nIf a reactive statement consists entirely of an assignment to an undeclared variable, Svelte will inject a let declaration on your behalf.\n\nDon't worry if this looks a little alien. It's valid (if unconventional) JavaScript, which Svelte interprets to mean 're-run this code whenever any of the referenced values change'. Once you get used to it, there's no going back.\n\nLet's use doubled in our markup:\n\nApp.svelte\n<button>...</button>\n\n<p>{count} doubled is {doubled}</p>\n\nOf course, you could just write {count * 2} in the markup instead — you don't have to use reactive values. Reactive values become particularly valuable (no pun intended) when you need to reference them multiple times, or you have values that depend on other reactive values.\n\nNote that reactive declarations and statements will run after other script code and before component markup is rendered.\n\nNext: Statements\n\nEdit this page\nsrc\nApp.svelte\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n⌄\n⌄\n⌄\n<script>\n\tlet count = 0;\n\n\n\tfunction increment() {\n\t\tcount += 1;\n\t}\n</script>\n\n\n<button on:click={increment}>\n\tClicked {count}\n\t{count === 1 ? 'time' : 'times'}\n</button>\n\n\ninitialising"
  },
  {
    "title": "API routes / GET handlers • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/get-handlers",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 3\n/\nAPI routes\n/\nGET handlers\n\nSvelteKit allows you to create more than just pages. We can also create API routes by adding a +server.js file that exports functions corresponding to HTTP methods: GET, PUT, POST, PATCH and DELETE.\n\nThis app fetches data from a /roll API route when you click the button. Create that route by adding a src/routes/roll/+server.js file:\n\nsrc/routes/roll/+server.js\nexport function GET() {\n\tconst number = Math.floor(Math.random() * 6) + 1;\n\n\treturn new Response(number, {\n\t\theaders: {\n\t\t\t'Content-Type': 'application/json'\n\t\t}\n\t});\n}\n\nClicking the button now works.\n\nRequest handlers must return a Response object. Since it's common to return JSON from an API route, SvelteKit provides a convenience function for generating these responses:\n\nsrc/routes/roll/+server.js\nimport { json } from '@sveltejs/kit';\n\nexport function GET() {\n\tconst number = Math.floor(Math.random() * 6) + 1;\n\n\treturn new Response(number, {\n\t\theaders: {\n\t\t\t'Content-Type': 'application/json'\n\t\t}\n\t});\n\treturn json(number);\n}\n\nNext: POST handlers\n\nEdit this page\nproject\nsrc\nroutes\n+page.svelte\napp.html\nstatic\nfavicon.png\npackage.json\nsvelte.config.js\nvite.config.js\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n⌄\n⌄\n⌄\n<script>\n\t/** @type {number} */\n\tlet number;\n\n\n\tasync function roll() {\n\t\tconst response = await fetch('/roll');\n\t\tnumber = await response.json();\n\t}\n</script>\n\n\n<button on:click={roll}>Roll the dice</button>\n\n\n{#if number !== undefined}\n\t<p>You rolled a {number}</p>\n{/if}\n\n\ninitialising"
  },
  {
    "title": "Hooks / handle • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/handle",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 4\n/\nHooks\n/\nhandle\n\nSvelteKit provides several hooks — ways to intercept and override the framework's default behaviour.\n\nThe most elementary hook is handle, which lives in src/hooks.server.js. It receives an event object along with a resolve function, and returns a Response.\n\nresolve is where the magic happens: SvelteKit matches the incoming request URL to a route of your app, imports the relevant code (+page.server.js and +page.svelte files and so on), loads the data needed by the route, and generates the response.\n\nThe default handle hook looks like this:\n\nsrc/hooks.server.js\nexport async function handle({ event, resolve }) {\n\treturn await resolve(event);\n}\n\nFor pages (as opposed to API routes), you can modify the generated HTML with transformPageChunk:\n\nsrc/hooks.server.js\nexport async function handle({ event, resolve }) {\n\treturn await resolve(event, {\n\t\ttransformPageChunk: ({ html }) => html.replace(\n\t\t\t'<body',\n\t\t\t'<body style=\"color: hotpink\"'\n\t\t)\n\t});\n}\n\nYou can also create entirely new routes:\n\nsrc/hooks.server.js\nexport async function handle({ event, resolve }) {\n\tif (event.url.pathname === '/ping') {\n\t\treturn new Response('pong');\n\t}\n\n\treturn await resolve(event, {\n\t\ttransformPageChunk: ({ html }) => html.replace(\n\t\t\t'<body',\n\t\t\t'<body style=\"color: hotpink\"'\n\t\t)\n\t});\n}\n\nNext: The RequestEvent object\n\nEdit this page\nproject\nsrc\nroutes\n+page.svelte\napp.html\nhooks.server.js\nstatic\nfavicon.png\npackage.json\nsvelte.config.js\nvite.config.js\nsolve \n1\n2\n<h1>hello world</h1>\n<a href=\"/ping\">ping</a>\ninitialising"
  },
  {
    "title": "Forms / The <form> element • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/the-form-element",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 3\n/\nForms\n/\nThe <form> element\n\nIn the chapter on loading data, we saw how to get data from the server to the browser. Sometimes you need to send data in the opposite direction, and that's where <form> — the web platform's way of submitting data — comes in.\n\nLet's build a todo app. We've already got an in-memory database set up in src/lib/server/database.js, and our load function in src/routes/+page.server.js uses the cookies API so that we can have a per-user todo list, but we need to add a <form> to create new todos:\n\nsrc/routes/+page.svelte\n<h1>todos</h1>\n\n<form method=\"POST\">\n\t<label>\n\t\tadd a todo:\n\t\t<input\n\t\t\tname=\"description\"\n\t\t\tautocomplete=\"off\"\n\t\t/>\n\t</label>\n</form>\n\n<ul class=\"todos\">\n\nIf we type something into the <input> and hit Enter, the browser makes a POST request (because of the method=\"POST\" attribute) to the current page. But that results in an error, because we haven't created a server-side action to handle the POST request. Let's do that now:\n\nsrc/routes/+page.server.js\nimport * as db from '$lib/server/database.js';\n\nexport function load({ cookies }) {\n\t// ...\n}\n\nexport const actions = {\n\tdefault: async ({ cookies, request }) => {\n\t\tconst data = await request.formData();\n\t\tdb.createTodo(cookies.get('userid'), data.get('description'));\n\t}\n};\n\nThe request is a standard Request object; await request.formData() returns a FormData instance.\n\nWhen we hit Enter, the database is updated and the page reloads with the new data.\n\nNotice that we haven't had to write any fetch code or anything like that — data updates automatically. And because we're using a <form> element, this app would work even if JavaScript was disabled or unavailable.\n\nNext: Named form actions\n\nEdit this page\nproject\nsrc\nlib\nserver\ndatabase.js\nroutes\n+page.server.js\n+page.svelte\nremove.svg\napp.html\nstatic\nfavicon.png\npackage.json\nsvelte.config.js\nvite.config.js\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n<script>\n\texport let data;\n</script>\n\n\n<div class=\"centered\">\n\t<h1>todos</h1>\n\n\n\t<ul class=\"todos\">\n\t\t{#each data.todos as todo (todo.id)}\n\t\t\t<li>\n\t\t\t\t{todo.description}\n\t\t\t</li>\n\t\t{/each}\n\t</ul>\n</div>\n\n\n<style>\n\t.centered {\n\t\tmax-width: 20em;\n\t\tmargin: 0 auto;\n\t}\n\n\n\tlabel {\n\t\twidth: 100%;\n\t}\n\n\n\tinput {\n\t\tflex: 1;\n\t}\n\n\n\tspan {\n\t\tflex: 1;\n\t}\n\n\n\tbutton {\n\t\tborder: none;\ninitialising"
  },
  {
    "title": "Page options / csr • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/csr",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 4\n/\nPage options\n/\ncsr\n\nClient-side rendering is what makes the page interactive — such as incrementing the counter when you click the button in this app — and enables SvelteKit to update the page upon navigation without a full-page reload.\n\nAs with ssr, you can disable client-side rendering altogether:\n\nsrc/routes/+page.server.js\nexport const csr = false;\n\nThis means that no JavaScript is served to the client, but it also means that your components are no longer interactive. It can be a useful way to check whether or not your application is usable for people who — for whatever reason — cannot use JavaScript.\n\nNext: prerender\n\nEdit this page\nproject\nsrc\nroutes\n+page.svelte\napp.html\nstatic\nfavicon.png\npackage.json\nsvelte.config.js\nvite.config.js\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n⌄\n⌄\n⌄\n<script>\n\timport { browser } from '$app/environment';\n\n\n\tlet count = 0;\n\n\n\tfunction increment() {\n\t\tcount += 1;\n\t}\n</script>\n\n\n<h1>Rendered {browser ? 'in the browser' : 'on the server'}</h1>\n\n\n<button on:click={increment}>\n\tClicks: {count}\n</button>\n\n\nbooting webcontainer"
  },
  {
    "title": "Advanced loading / Universal load functions • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/universal-load-functions",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 4\n/\nAdvanced loading\n/\nUniversal load functions\n\nIn the previous section on loading we loaded data from the server using +page.server.js and +layout.server.js files. This is very convenient if you need to do things like getting data directly from a database, or reading cookies.\n\nSometimes it doesn't make sense to load data from the server when doing a client-side navigation. For example:\n\nYou're loading data from an external API\nYou want to use in-memory data if it's available\nYou want to delay navigation until an image has been preloaded, to avoid pop-in\nYou need to return something from load that can't be serialized (SvelteKit uses devalue to turn server data into JSON), such as a component or a store\n\nIn this exercise, we're dealing with the latter case. The server load functions in src/routes/red/+page.server.js, src/routes/green/+page.server.js and src/routes/blue/+page.server.js return a component constructor, which can't be serialized like data. If you navigate to /red, /green or /blue, you'll see a 'Data returned from load ... is not serializable' error in the terminal.\n\nTo turn the server load functions into universal load functions, rename each +page.server.js file to +page.js. Now, the functions will run on the server during server-side rendering, but will also run in the browser when the app hydrates or the user performs a client-side navigation.\n\nWe can now use the component returned from these load functions like any other value, including in src/routes/+layout.svelte:\n\nsrc/routes/+layout.svelte\n<nav\n\tclass:has-color={!!$page.data.color}\n\tstyle:background={$page.data.color ?? 'var(--bg-2)'}\n>\n\t<a href=\"/\">home</a>\n\t<a href=\"/red\">red</a>\n\t<a href=\"/green\">green</a>\n\t<a href=\"/blue\">blue</a>\n\n\t{#if $page.data.component}\n\t\t<svelte:component this={$page.data.component} />\n\t{/if}\n</nav>\n\nRead the documentation to learn more about the distinction between server load functions and universal load functions, and when to use which.\n\nNext: Using both load functions\n\nEdit this page\nproject\nsrc\nroutes\nblue\n+page.server.js\n+page.svelte\nblue.svelte\ngreen\n+page.server.js\n+page.svelte\ngreen.svelte\nred\n+page.server.js\n+page.svelte\nred.svelte\n+layout.svelte\n+page.svelte\napp.html\nstatic\nfavicon.png\npackage.json\nsvelte.config.js\nvite.config.js\nsolve \n1\n<h1>pick a colour</h1>\ninitialising"
  },
  {
    "title": "Headers and cookies / Reading and writing cookies • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/cookies",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 3\n/\nHeaders and cookies\n/\nReading and writing cookies\n\nThe setHeaders function can't be used with the Set-Cookie header. Instead, you should use the cookies API.\n\nIn your load functions, you can read a cookie with cookies.get(name, options):\n\nsrc/routes/+page.server.js\nexport function load({ cookies }) {\n\tconst visited = cookies.get('visited');\n\n\treturn {\n\t\tvisited: visited === 'true'\n\t};\n}\n\nTo set a cookie, use cookies.set(name, value, options). It's strongly recommended that you explicitly configure the path when setting a cookie, since browsers' default behaviour — somewhat uselessly — is to set the cookie on the parent of the current path.\n\nsrc/routes/+page.server.js\nexport function load({ cookies }) {\n\tconst visited = cookies.get('visited');\n\n\tcookies.set('visited', 'true', { path: '/' });\n\n\treturn {\n\t\tvisited: visited === 'true'\n\t};\n}\n\nNow, if you reload the iframe, Hello stranger! becomes Hello friend!.\n\nCalling cookies.set(name, ...) causes a Set-Cookie header to be written, but it also updates the internal map of cookies, meaning any subsequent calls to cookies.get(name) during the same request will return the updated value. Under the hood, the cookies API uses the popular cookie package — the options passed to cookies.get and cookies.set correspond to the parse and serialize options from the cookie documentation. SvelteKit sets the following defaults to make your cookies more secure:\n\n{\n\thttpOnly: true,\n\tsecure: true,\n\tsameSite: 'lax'\n}\n\nNext: Shared modules\n\nEdit this page\nproject\nsrc\nroutes\n+page.server.js\n+page.svelte\napp.html\nstatic\nfavicon.png\npackage.json\nsvelte.config.js\nvite.config.js\nsolve \n1\n2\n3\n4\n5\n⌄\n<script>\n\texport let data;\n</script>\n\n\n<h1>Hello {data.visited ? 'friend' : 'stranger'}!</h1>\ninitialising"
  },
  {
    "title": "Advanced bindings / Media elements • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/media-elements",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 2\n/\nAdvanced bindings\n/\nMedia elements\n\nYou can bind to properties of <audio> and <video> elements, making it easy to (for example) build custom player UI, like AudioPlayer.svelte.\n\nFirst, add the <audio> element along with its bindings (we'll use the shorthand form for src, duration and paused):\n\nAudioPlayer.svelte\n<div class=\"player\" class:paused>\n\t<audio\n\t\t{src}\n\t\tbind:currentTime={time}\n\t\tbind:duration\n\t\tbind:paused\n\t/>\n\n\t<button\n\t\tclass=\"play\"\n\t\taria-label={paused ? 'play' : 'pause'}\n\t/>\n\nNext, add an event handler to the <button> that toggles paused:\n\nAudioPlayer.svelte\n<button\n\tclass=\"play\"\n\taria-label={paused ? 'play' : 'pause'}\n\ton:click={() => paused = !paused}\n/>\n\nOur audio player now has basic functionality. Let's add the ability to seek to a specific part of a track by dragging the slider. Inside the slider's pointerdown handler there's a seek function, where we can update time:\n\nAudioPlayer.svelte\nfunction seek(e) {\n\tconst { left, width } = div.getBoundingClientRect();\n\n\tlet p = (e.clientX - left) / width;\n\tif (p < 0) p = 0;\n\tif (p > 1) p = 1;\n\n\ttime = p * duration;\n}\n\nWhen the track ends, be kind — rewind:\n\nAudioPlayer.svelte\n<audio\n\t{src}\n\tbind:currentTime={time}\n\tbind:duration\n\tbind:paused\n\ton:ended={() => {\n\t\ttime = 0;\n\t}}\n/>\n\nThe complete set of bindings for <audio> and <video> is as follows — seven readonly bindings...\n\nduration (readonly) — the total duration, in seconds\nbuffered (readonly) — an array of {start, end} objects\nseekable (readonly) — ditto\nplayed (readonly) — ditto\nseeking (readonly) — boolean\nended (readonly) — boolean\nreadyState (readonly) — number between (and including) 0 and 4\n\n...and five two-way bindings:\n\ncurrentTime — the current position of the playhead, in seconds\nplaybackRate — speed up or slow down (1 is 'normal')\npaused — this one should be self-explanatory\nvolume — a value between 0 and 1\nmuted — a boolean value where true is muted\n\nVideos additionally have readonly videoWidth and videoHeight bindings.\n\nNext: Dimensions\n\nEdit this page\nsrc\nApp.svelte\nAudioPlayer.svelte\npause.svg\nplay.svg\nsound-off.svg\nsound-on.svg\ntracks.js\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n⌄\n⌄\n⌄\n⌄\n⌄\n<script>\n\timport AudioPlayer from './AudioPlayer.svelte';\n\timport { tracks } from './tracks.js';\n</script>\n\n\n<div class=\"centered\">\n\t{#each tracks as track}\n\t\t<AudioPlayer {...track} />\n\t{/each}\n</div>\n\n\n<style>\n\t.centered {\n\t\tdisplay: flex;\n\t\tflex-direction: column;\n\t\theight: 100%;\n\t\tjustify-content: center;\n\t\tgap: 0.5em;\n\t\tmax-width: 40em;\n\t\tmargin: 0 auto;\n\t}\n</style>\ninitialising"
  },
  {
    "title": "Special elements / <svelte:fragment> • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/svelte-fragment",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 2\n/\nSpecial elements\n/\n<svelte:fragment>\n\nThe <svelte:fragment> element allows you to place content in a named slot without wrapping it in a container DOM element.\n\nIn this exercise, we're making a Tic-Tac-Toe game. To form a grid, the <button> elements in App.svelte should be direct descendants of the <div class=\"board\"> element in Board.svelte.\n\nAt the moment, it's horribly broken, because they're children of <div slot=\"game\"> instead. Let's fix it:\n\nApp.svelte\n<svelte:fragment slot=\"game\">\n\t{#each squares as square, i}\n\t\t<button\n\t\t\tclass=\"square\"\n\t\t\tclass:winning={winningLine?.includes(i)}\n\t\t\tdisabled={square}\n\t\t\ton:click={() => {\n\t\t\t\tsquares[i] = next;\n\t\t\t\tnext = next === 'x' ? 'o' : 'x';\n\t\t\t}}\n\t\t>\n\t\t\t{square}\n\t\t</button>\n\t{/each}\n</svelte:fragment>\n\nNext: Module context\n\nEdit this page\nsrc\nApp.svelte\nBoard.svelte\nutils.js\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n<script>\n\timport Board from './Board.svelte';\n\timport { getWinningLine } from './utils.js';\n\n\n\tlet squares = Array(9).fill('');\n\tlet next = 'x';\n\n\n\t$: winningLine = getWinningLine(squares);\n</script>\n\n\n<div class=\"container\">\n\t<Board size={3}>\n\t\t<div slot=\"game\">\n\t\t\t{#each squares as square, i}\n\t\t\t\t<button\n\t\t\t\t\tclass=\"square\"\n\t\t\t\t\tclass:winning={winningLine?.includes(i)}\n\t\t\t\t\tdisabled={square}\n\t\t\t\t\ton:click={() => {\n\t\t\t\t\t\tsquares[i] = next;\n\t\t\t\t\t\tnext = next === 'x' ? 'o' : 'x';\n\t\t\t\t\t}}\n\t\t\t\t>\n\t\t\t\t\t{square}\n\t\t\t\t</button>\n\t\t\t{/each}\n\t\t</div>\n\n\n\t\t<div slot=\"controls\">\n\t\t\t<button on:click={() => {\n\t\t\t\tsquares = Array(9).fill('');\n\t\t\t\tnext = 'x';\n\t\t\t}}>\n\t\t\t\tReset\n\t\t\t</button>\n\t\t</div>\ninitialising"
  },
  {
    "title": "Transitions / Custom CSS transitions • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/custom-css-transitions",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 2\n/\nTransitions\n/\nCustom CSS transitions\n\nThe svelte/transition module has a handful of built-in transitions, but it's very easy to create your own. By way of example, this is the source of the fade transition:\n\nfunction fade(node, { delay = 0, duration = 400 }) {\n\tconst o = +getComputedStyle(node).opacity;\n\n\treturn {\n\t\tdelay,\n\t\tduration,\n\t\tcss: (t) => `opacity: ${t * o}`\n\t};\n}\n\nThe function takes two arguments — the node to which the transition is applied, and any parameters that were passed in — and returns a transition object which can have the following properties:\n\ndelay — milliseconds before the transition begins\nduration — length of the transition in milliseconds\neasing — a p => t easing function (see the chapter on tweening)\ncss — a (t, u) => css function, where u === 1 - t\ntick — a (t, u) => {...} function that has some effect on the node\n\nThe t value is 0 at the beginning of an intro or the end of an outro, and 1 at the end of an intro or beginning of an outro.\n\nMost of the time you should return the css property and not the tick property, as CSS animations run off the main thread to prevent jank where possible. Svelte 'simulates' the transition and constructs a CSS animation, then lets it run.\n\nFor example, the fade transition generates a CSS animation somewhat like this:\n\n0% { opacity: 0 }\n10% { opacity: 0.1 }\n20% { opacity: 0.2 }\n/* ... */\n100% { opacity: 1 }\n\nWe can get a lot more creative though. Let's make something truly gratuitous:\n\nApp.svelte\n<script>\n\timport { fade } from 'svelte/transition';\n\timport { elasticOut } from 'svelte/easing';\n\n\tlet visible = true;\n\n\tfunction spin(node, { duration }) {\n\t\treturn {\n\t\t\tduration,\n\t\t\tcss: t => {\n\t\t\t\tconst eased = elasticOut(t);\n\n\t\t\t\treturn `\n\t\t\t\t\ttransform: scale(${eased}) rotate(${eased * 1080}deg);\n\t\t\t\t\tcolor: hsl(\n\t\t\t\t\t\t${Math.trunc(t * 360)},\n\t\t\t\t\t\t${Math.min(100, 1000 * (1 - t))}%,\n\t\t\t\t\t\t${Math.min(50, 500 * (1 - t))}%\n\t\t\t\t\t);`\n\t\t\t}\n\t\t};\n\t}\n</script>\n\nRemember: with great power comes great responsibility.\n\nNext: Custom JS transitions\n\nEdit this page\nsrc\nApp.svelte\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n<script>\n\timport { fade } from 'svelte/transition';\n\n\n\tlet visible = true;\n\n\n\tfunction spin(node, { duration }) {\n\t\treturn {\n\t\t\tduration,\n\t\t\tcss: (t) => ``\n\t\t};\n\t}\n</script>\n\n\n<label>\n\t<input type=\"checkbox\" bind:checked={visible} />\n\tvisible\n</label>\n\n\n{#if visible}\n\t<div\n\t\tclass=\"centered\"\n\t\tin:spin={{ duration: 8000 }}\n\t\tout:fade\n\t>\n\t\t<span>transitions!</span>\n\t</div>\n{/if}\n\n\n<style>\n\t.centered {\n\t\tposition: absolute;\n\t\tleft: 50%;\n\t\ttop: 50%;\n\t\ttransform: translate(-50%, -50%);\n\t}\n\n\ninitialising"
  },
  {
    "title": "Stores / Auto-subscriptions • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/auto-subscriptions",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 1\n/\nStores\n/\nAuto-subscriptions\n\nThe app in the previous example works, but there's a subtle bug — the store is subscribed to, but never unsubscribed. If the component was instantiated and destroyed many times, this would result in a memory leak.\n\nStart by declaring unsubscribe in App.svelte:\n\nApp.svelte\nconst unsubscribe = count.subscribe((value) => {\n\tcount_value = value;\n});\n\nCalling a subscribe method returns an unsubscribe function.\n\nYou now declared unsubscribe, but it still needs to be called, for example through the onDestroy lifecycle hook:\n\nApp.svelte\n<script>\n\timport { onDestroy } from 'svelte';\n\timport { count } from './stores.js';\n\timport Incrementer from './Incrementer.svelte';\n\timport Decrementer from './Decrementer.svelte';\n\timport Resetter from './Resetter.svelte';\n\n\tlet count_value;\n\n\tconst unsubscribe = count.subscribe(value => {\n\t\tcount_value = value;\n\t});\n\n\tonDestroy(unsubscribe);\n</script>\n\n<h1>The count is {count_value}</h1>\n\nIt starts to get a bit boilerplatey though, especially if your component subscribes to multiple stores. Instead, Svelte has a trick up its sleeve — you can reference a store value by prefixing the store name with $:\n\nApp.svelte\n<script>\n\timport { onDestroy } from 'svelte';\n\timport { count } from './stores.js';\n\timport Incrementer from './Incrementer.svelte';\n\timport Decrementer from './Decrementer.svelte';\n\timport Resetter from './Resetter.svelte';\n\n\tlet count_value;\n\n\tconst unsubscribe = count.subscribe(value => {\n\t\tcount_value = value;\n\t});\n\n\tonDestroy(unsubscribe);\n</script>\n\n<h1>The count is {$count}</h1>\n\nAuto-subscription only works with store variables that are declared (or imported) at the top-level scope of a component.\n\nYou're not limited to using $count inside the markup, either — you can use it anywhere in the <script> as well, such as in event handlers or reactive declarations.\n\nAny name beginning with $ is assumed to refer to a store value. It's effectively a reserved character — Svelte will prevent you from declaring your own variables with a $ prefix.\n\nNext: Readable stores\n\nEdit this page\nsrc\nApp.svelte\nDecrementer.svelte\nIncrementer.svelte\nResetter.svelte\nstores.js\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n⌄\n⌄\n<script>\n\timport { count } from './stores.js';\n\timport Incrementer from './Incrementer.svelte';\n\timport Decrementer from './Decrementer.svelte';\n\timport Resetter from './Resetter.svelte';\n\n\n\tlet count_value;\n\n\n\tcount.subscribe((value) => {\n\t\tcount_value = value;\n\t});\n</script>\n\n\n<h1>The count is {count_value}</h1>\n\n\n<Incrementer />\n<Decrementer />\n<Resetter />\n\n\ninitialising"
  },
  {
    "title": "Reactivity / Assignments • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/reactive-assignments",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 1\n/\nReactivity\n/\nAssignments\n\nAt the heart of Svelte is a powerful system of reactivity for keeping the DOM in sync with your application state — for example, in response to an event.\n\nTo demonstrate it, we first need to wire up an event handler (we'll learn more about these later):\n\nApp.svelte\n<button on:click={increment}>\n\tClicked {count}\n\t{count === 1 ? 'time' : 'times'}\n</button>\n\nInside the increment function, all we need to do is change the value of count:\n\nApp.svelte\nfunction increment() {\n\tcount += 1;\n}\n\nSvelte 'instruments' this assignment with some code that tells it the DOM will need to be updated.\n\nNext: Declarations\n\nEdit this page\nsrc\nApp.svelte\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n⌄\n⌄\n⌄\n<script>\n\tlet count = 0;\n\n\n\tfunction increment() {\n\t\t// event handler code goes here\n\t}\n</script>\n\n\n<button>\n\tClicked {count}\n\t{count === 1 ? 'time' : 'times'}\n</button>\n\n\ninitialising"
  },
  {
    "title": "Advanced routing / Breaking out of layouts • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/breaking-out-of-layouts",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 4\n/\nAdvanced routing\n/\nBreaking out of layouts\n\nOrdinarily, a page inherits every layout above it, meaning that src/routes/a/b/c/+page.svelte inherits four layouts:\n\nsrc/routes/+layout.svelte\nsrc/routes/a/+layout.svelte\nsrc/routes/a/b/+layout.svelte\nsrc/routes/a/b/c/+layout.svelte\n\nOccasionally, it's useful to break out of the current layout hierarchy. We can do that by adding the @ sign followed by the name of the parent segment to 'reset' to — for example +page@b.svelte would put /a/b/c inside src/routes/a/b/+layout.svelte, while +page@a.svelte would put it inside src/routes/a/+layout.svelte.\n\nLet's reset it all the way to the root layout, by renaming it to +page@.svelte.\n\nThe root layout applies to every page of your app, you cannot break out of it.\n\nNext: Advanced loading\n\nEdit this page\nproject\nsrc\nroutes\na\nb\nc\n+layout.svelte\n+page.svelte\n+layout.svelte\n+page.svelte\n+layout.svelte\n+page.svelte\n+layout.svelte\n+page.svelte\napp.html\nstatic\nfavicon.png\npackage.json\nsvelte.config.js\nvite.config.js\nsolve \n1\n2\n<h1>home</h1>\n\n\ninitialising"
  },
  {
    "title": "Headers and cookies / Setting headers • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/headers",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 3\n/\nHeaders and cookies\n/\nSetting headers\n\nInside a load function (as well as in form actions, hooks and API routes, which we'll learn about later) you have access to a setHeaders function, which — unsurprisingly — can be used to set headers on the response.\n\nMost commonly, you'd use it to customise caching behaviour with the Cache-Control response header, but for the sake of this tutorial we'll do something less advisable and more dramatic:\n\nsrc/routes/+page.server.js\nexport function load({ setHeaders }) {\n\tsetHeaders({\n\t\t'Content-Type': 'text/plain'\n\t});\n}\n\n(You may need to reload the iframe to see the effect.)\n\nNext: Reading and writing cookies\n\nEdit this page\nproject\nsrc\nroutes\n+page.server.js\n+page.svelte\napp.html\nstatic\nfavicon.png\npackage.json\nsvelte.config.js\nvite.config.js\nsolve \n1\n<h1>hello world</h1>\ninitialising"
  },
  {
    "title": "Module context / Sharing code • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/sharing-code",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 2\n/\nModule context\n/\nSharing code\n\nIn all the examples we've seen so far, the <script> block contains code that runs when each component instance is initialised. For the vast majority of components, that's all you'll ever need.\n\nVery occasionally, you'll need to run some code outside of an individual component instance. For example: returning to our custom audio player from a previous exercise, you can play all four tracks simultaneously. It would be better if playing one stopped all the others.\n\nWe can do that by declaring a <script context=\"module\"> block. Code contained inside it will run once, when the module first evaluates, rather than when a component is instantiated. Place this at the top of AudioPlayer.svelte (note that this is a separate script tag):\n\nAudioPlayer.svelte\n<script context=\"module\">\n\tlet current;\n</script>\n\nIt's now possible for the components to 'talk' to each other without any state management:\n\nAudioPlayer.svelte\n<audio\n\tsrc={src}\n\tbind:currentTime={time}\n\tbind:duration\n\tbind:paused\n\ton:play={(e) => {\n\t\tconst audio = e.currentTarget;\n\n\t\tif (audio !== current) {\n\t\t\tcurrent?.pause();\n\t\t\tcurrent = audio;\n\t\t}\n\t}}\n\ton:ended={() => {\n\t\ttime = 0;\n\t}}\n/>\n\nNext: Exports\n\nEdit this page\nsrc\nApp.svelte\nAudioPlayer.svelte\npause.svg\nplay.svg\nsound-off.svg\nsound-on.svg\ntracks.js\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n⌄\n⌄\n⌄\n⌄\n⌄\n<script>\n\timport AudioPlayer from './AudioPlayer.svelte';\n\timport { tracks } from './tracks.js';\n</script>\n\n\n<div class=\"centered\">\n\t{#each tracks as track}\n\t\t<AudioPlayer {...track} />\n\t{/each}\n</div>\n\n\n<style>\n\t.centered {\n\t\tdisplay: flex;\n\t\tflex-direction: column;\n\t\theight: 100%;\n\t\tjustify-content: center;\n\t\tgap: 0.5em;\n\t\tmax-width: 40em;\n\t\tmargin: 0 auto;\n\t}\n</style>\nbooting webcontainer"
  },
  {
    "title": "Page options / prerender • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/prerender",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nTutorial\nSvelte\nSvelteKit\nPart 4\n/\nPage options\n/\nprerender\n\nPrerendering means generating HTML for a page once, at build time, rather than dynamically for each request.\n\nThe advantage is that serving static data is extremely cheap and performant, allowing you to easily serve large numbers of users without worrying about cache-control headers (which are easy to get wrong).\n\nThe tradeoff is that the build process takes longer, and prerendered content can only be updated by building and deploying a new version of the application.\n\nTo prerender a page, set prerender to true:\n\nsrc/routes/+page.server.js\nexport const prerender = true;\n\nHere in the tutorial, this won't have any observable effect, since the application is running in dev mode.\n\nNot all pages can be prerendered. The basic rule is this: for content to be prerenderable, any two users hitting it directly must get the same content from the server, and the page must not contain form actions. Pages with dynamic route parameters can be prerendered as long as they are specified in the prerender.entries configuration or can be reached by following links from pages that are in prerender.entries.\n\nSetting prerender to true inside your root +layout.server.js effectively turns SvelteKit into a static site generator (SSG).\n\nNext: trailingSlash\n\nEdit this page\nproject\nsrc\nroutes\n+page.svelte\napp.html\nstatic\nfavicon.png\npackage.json\nsvelte.config.js\nvite.config.js\nsolve \n1\n2\n<h1>Prerendering</h1>\n \ninitialising"
  },
  {
    "title": "Transitions / In and out • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/in-and-out",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 2\n/\nTransitions\n/\nIn and out\n\nInstead of the transition directive, an element can have an in or an out directive, or both together. Import fade alongside fly...\n\nApp.svelte\nimport { fade, fly } from 'svelte/transition';\n\n...then replace the transition directive with separate in and out directives:\n\nApp.svelte\n<p in:fly={{ y: 200, duration: 2000 }} out:fade>\n\tFlies in, fades out\n</p>\n\nIn this case, the transitions are not reversed.\n\nNext: Custom CSS transitions\n\nEdit this page\nsrc\nApp.svelte\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n⌄\n⌄\n⌄\n⌄\n<script>\n\timport { fly } from 'svelte/transition';\n\tlet visible = true;\n</script>\n\n\n<label>\n\t<input type=\"checkbox\" bind:checked={visible} />\n\tvisible\n</label>\n\n\n{#if visible}\n\t<p transition:fly={{ y: 200, duration: 2000 }}>\n\t\tFlies in and out\n\t</p>\n{/if}\n\n\ninitialising"
  },
  {
    "title": "Stores / Readable stores • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/readable-stores",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 1\n/\nStores\n/\nReadable stores\n\nNot all stores should be writable by whoever has a reference to them. For example, you might have a store representing the mouse position or the user's geolocation, and it doesn't make sense to be able to set those values from 'outside'. For those cases, we have readable stores.\n\nOpen stores.js. The first argument to readable is an initial value, which can be null or undefined if you don't have one yet. The second argument is a start function that takes a set callback and returns a stop function. The start function is called when the store gets its first subscriber; stop is called when the last subscriber unsubscribes.\n\nstores.js\nexport const time = readable(new Date(), function start(set) {\n\tconst interval = setInterval(() => {\n\t\tset(new Date());\n\t}, 1000);\n\n\treturn function stop() {\n\t\tclearInterval(interval);\n\t};\n});\n\nNext: Derived stores\n\nEdit this page\nsrc\nApp.svelte\nstores.js\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n⌄\n⌄\n<script>\n\timport { time } from './stores.js';\n\n\n\tconst formatter = new Intl.DateTimeFormat(\n\t\t'en',\n\t\t{\n\t\t\thour12: true,\n\t\t\thour: 'numeric',\n\t\t\tminute: '2-digit',\n\t\t\tsecond: '2-digit'\n\t\t}\n\t);\n</script>\n\n\n<h1>The time is {formatter.format($time)}</h1>\n\n\ninitialising"
  },
  {
    "title": "Introduction / HTML tags • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/html-tags",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 1\n/\nIntroduction\n/\nHTML tags\n\nOrdinarily, strings are inserted as plain text, meaning that characters like < and > have no special meaning.\n\nBut sometimes you need to render HTML directly into a component. For example, the words you're reading right now exist in a markdown file that gets included on this page as a blob of HTML.\n\nIn Svelte, you do this with the special {@html ...} tag:\n\nApp.svelte\n<p>{@html string}</p>\n\nWarning! Svelte doesn't perform any sanitization of the expression inside {@html ...} before it gets inserted into the DOM. This isn't an issue if the content is something you trust like an article you wrote yourself. However if it's some untrusted user content, e.g. a comment on an article, then it's critical that you manually escape it, otherwise you risk exposing your users to Cross-Site Scripting (XSS) attacks.\n\nNext: Reactivity\n\nEdit this page\nsrc\nApp.svelte\nsolve \n1\n2\n3\n4\n5\n6\n⌄\n<script>\n\tlet string = `this string contains some <strong>HTML!!!</strong>`;\n</script>\n\n\n<p>{string}</p>\n\n\ninitialising"
  },
  {
    "title": "Advanced routing / Route groups • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/route-groups",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 4\n/\nAdvanced routing\n/\nRoute groups\n\nAs we saw in the routing introduction, layouts are a way to share UI and data loading logic between different routes.\n\nSometimes it's useful to use layouts without affecting the route — for example, you might need your /app and /account routes to be behind authentication, while your /about page is open to the world. We can do this with a route group, which is a directory in parentheses.\n\nCreate an (authed) group by renaming account to (authed)/account then renaming app to (authed)/app.\n\nNow we can control access to these routes by creating src/routes/(authed)/+layout.server.js:\n\nsrc/routes/(authed)/+layout.server.js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ cookies, url }) {\n\tif (!cookies.get('logged_in')) {\n\t\tthrow redirect(303, `/login?redirectTo=${url.pathname}`);\n\t}\n}\n\nIf you try to visit these pages, you'll be redirected to the /login route, which has a form action in src/routes/login/+page.server.js that sets the logged_in cookie.\n\nWe can also add some UI to these two routes by adding a src/routes/(authed)/+layout.svelte file:\n\nsrc/routes/(authed)/+layout.svelte\n<slot />\n\n<form method=\"POST\" action=\"/logout\">\n\t<button>log out</button>\n</form>\n\nNext: Breaking out of layouts\n\nEdit this page\nproject\nsrc\nroutes\nabout\n+page.svelte\naccount\n+page.svelte\napp\n+page.svelte\nlogin\n+page.server.js\n+page.svelte\nlogout\n+page.server.js\n+layout.svelte\n+page.svelte\napp.html\nstatic\nfavicon.png\npackage.json\nsvelte.config.js\nvite.config.js\nsolve \n1\n2\n3\n4\n<h1>home</h1>\n\n\n<p>this is the home page.</p>\n\n\nbooting webcontainer"
  },
  {
    "title": "Loading data / Layout data • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/layout-data",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 3\n/\nLoading data\n/\nLayout data\n\nJust as +layout.svelte files create UI for every child route, +layout.server.js files load data for every child route.\n\nSuppose we'd like to add a 'more posts' sidebar to our blog post page. We could return summaries from the load function in src/routes/blog/[slug]/+page.server.js, like we do in src/routes/blog/+page.server.js, but that would be repetitive.\n\nInstead, let's rename src/routes/blog/+page.server.js to src/routes/blog/+layout.server.js. Notice that the /blog route continues to work — data.summaries is still available to the page.\n\nNow, add a sidebar in the layout for the post page:\n\nsrc/routes/blog/[slug]/+layout.svelte\n<script>\n\texport let data;\n</script>\n\n<div class=\"layout\">\n\t<main>\n\t\t<slot />\n\t</main>\n\n\t<aside>\n\t\t<h2>More posts</h2>\n\t\t<ul>\n\t\t\t{#each data.summaries as { slug, title }}\n\t\t\t\t<li>\n\t\t\t\t\t<a href=\"/blog/{slug}\">{title}</a>\n\t\t\t\t</li>\n\t\t\t{/each}\n\t\t</ul>\n\t</aside>\n</div>\n\n<style>\n\t@media (min-width: 640px) {\n\t\t.layout {\n\t\t\tdisplay: grid;\n\t\t\tgap: 2em;\n\t\t\tgrid-template-columns: 1fr 16em;\n\t\t}\n\t}\n</style>\n\nThe layout (and any page below it) inherits data.summaries from the parent +layout.server.js.\n\nWhen we navigate from one post to another, we only need to load the data for the post itself — the layout data is still valid. See the documentation on invalidation to learn more.\n\nNext: Headers and cookies\n\nEdit this page\nproject\nsrc\nroutes\nblog\n[slug]\n+layout.svelte\n+page.server.js\n+page.svelte\n+page.server.js\n+page.svelte\ndata.js\n+layout.svelte\n+page.svelte\napp.html\nstatic\nfavicon.png\npackage.json\nsvelte.config.js\nvite.config.js\nsolve \n1\n2\n<p>home</p>\n\n\nbooting webcontainer"
  },
  {
    "title": "Module context / Exports • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/module-exports",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 2\n/\nModule context\n/\nExports\n\nAnything exported from a context=\"module\" script block becomes an export from the module itself. Let's export a stopAll function:\n\nAudioPlayer.svelte\n<script context=\"module\">\n\tlet current;\n\n\texport function stopAll() {\n\t\tcurrent?.pause();\n\t}\n</script>\n\nWe can now import stopAll in App.svelte...\n\nApp.svelte\n<script>\n\timport AudioPlayer, { stopAll } from './AudioPlayer.svelte';\n\timport { tracks } from './tracks.js';\n</script>\n\n...and use it in an event handler:\n\nApp.svelte\n<div class=\"centered\">\n\t{#each tracks as track}\n\t\t<AudioPlayer {...track} />\n\t{/each}\n\n\t<button on:click={stopAll}>\n\t\tstop all\n\t</button>\n</div>\n\nYou can't have a default export, because the component is the default export.\n\nNext: Miscellaneous\n\nEdit this page\nsrc\nApp.svelte\nAudioPlayer.svelte\npause.svg\nplay.svg\nsound-off.svg\nsound-on.svg\ntracks.js\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n⌄\n⌄\n⌄\n⌄\n⌄\n<script>\n\timport AudioPlayer from './AudioPlayer.svelte';\n\timport { tracks } from './tracks.js';\n</script>\n\n\n<div class=\"centered\">\n\t{#each tracks as track}\n\t\t<AudioPlayer {...track} />\n\t{/each}\n</div>\n\n\n<style>\n\t.centered {\n\t\tdisplay: flex;\n\t\tflex-direction: column;\n\t\theight: 100%;\n\t\tjustify-content: center;\n\t\tgap: 0.5em;\n\t\tmax-width: 40em;\n\t\tmargin: 0 auto;\n\t}\n</style>\ninitialising"
  },
  {
    "title": "Page options / trailingSlash • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/trailingslash",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 4\n/\nPage options\n/\ntrailingSlash\n\nTwo URLs like /foo and /foo/ might look the same, but they're actually different. A relative URL like ./bar will resolve to /bar in the first case and /foo/bar in the second, and search engines will treat them as separate entries, harming your SEO.\n\nIn short, being loosey-goosey about trailing slashes is a bad idea. By default, SvelteKit strips trailing slashes, meaning that a request for /foo/ will result in a redirect to /foo.\n\nIf you instead want to ensure that a trailing slash is always present, you can specify the trailingSlash option accordingly:\n\nsrc/routes/always/+page.server.js\nexport const trailingSlash = 'always';\n\nTo accommodate both cases (this is not recommended!), use 'ignore':\n\nsrc/routes/ignore/+page.server.js\nexport const trailingSlash = 'ignore';\n\nThe default value is 'never'.\n\nWhether or not trailing slashes are applied affects prerendering. A URL like /always/ will be saved to disk as always/index.html whereas a URL like /never will be saved as never.html.\n\nNext: Link options\n\nEdit this page\nproject\nsrc\nroutes\nalways\n+page.svelte\nignore\n+page.svelte\nnever\n+page.svelte\n+layout.svelte\n+page.svelte\napp.html\nstatic\nfavicon.png\npackage.json\nsvelte.config.js\nvite.config.js\nsolve \n1\n2\n<h1>trailingSlash</h1>\n\n\ninitialising"
  },
  {
    "title": "Transitions / Adding parameters • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/adding-parameters-to-transitions",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 2\n/\nTransitions\n/\nAdding parameters\n\nTransition functions can accept parameters. Replace the fade transition with fly...\n\nApp.svelte\n<script>\n\timport { fly } from 'svelte/transition';\n\tlet visible = true;\n</script>\n\n...and apply it to the <p> along with some options:\n\nApp.svelte\n<p transition:fly={{ y: 200, duration: 2000 }}>\n\tFlies in and out\n</p>\n\nNote that the transition is reversible — if you toggle the checkbox while the transition is ongoing, it transitions from the current point, rather than the beginning or the end.\n\nNext: In and out\n\nEdit this page\nsrc\nApp.svelte\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n⌄\n⌄\n⌄\n⌄\n<script>\n\timport { fade } from 'svelte/transition';\n\tlet visible = true;\n</script>\n\n\n<label>\n\t<input type=\"checkbox\" bind:checked={visible} />\n\tvisible\n</label>\n\n\n{#if visible}\n\t<p transition:fade>\n\t\tFades in and out\n\t</p>\n{/if}\n\n\ninitialising"
  },
  {
    "title": "Introduction / Nested components • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/nested-components",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 1\n/\nIntroduction\n/\nNested components\n\nIt would be impractical to put your entire app in a single component. Instead, we can import components from other files and include them in our markup.\n\nAdd a <script> tag to the top of App.svelte that imports Nested.svelte...\n\nApp.svelte\n<script>\n\timport Nested from './Nested.svelte';\n</script>\n\n...and include a <Nested /> component:\n\nApp.svelte\n<p>This is a paragraph.</p>\n<Nested />\n\nNotice that even though Nested.svelte has a <p> element, the styles from App.svelte don't leak in.\n\nComponent names are always capitalised, to distinguish them from HTML elements.\n\nNext: HTML tags\n\nEdit this page\nsrc\nApp.svelte\nNested.svelte\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n⌄\n⌄\n<p>This is a paragraph.</p>\n\n\n<style>\n\tp {\n\t\tcolor: goldenrod;\n\t\tfont-family: 'Comic Sans MS', cursive;\n\t\tfont-size: 2em;\n\t}\n</style>\n\n\ninitialising"
  },
  {
    "title": "Stores / Derived stores • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/derived-stores",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nTutorial\nSvelte\nSvelteKit\nPart 1\n/\nStores\n/\nDerived stores\n\nYou can create a store whose value is based on the value of one or more other stores with derived. Building on our previous example, we can create a store that derives the time the page has been open:\n\nstores.js\nexport const elapsed = derived(\n\ttime,\n\t($time) => Math.round(($time - start) / 1000)\n);\n\nIt's possible to derive a store from multiple input stores, and to explicitly set a value instead of returning it (which is useful for deriving values asynchronously). Consult the API reference for more information.\n\nNext: Custom stores\n\nEdit this page\nsrc\nApp.svelte\nstores.js\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n<script>\n\timport { time, elapsed } from './stores.js';\n \n\tconst formatter = new Intl.DateTimeFormat(\n\t\t'en',\n\t\t{\n\t\t\thour12: true,\n\t\t\thour: 'numeric',\n\t\t\tminute: '2-digit',\n\t\t\tsecond: '2-digit'\n\t\t}\n\t);\n</script>\n \n<h1>The time is {formatter.format($time)}</h1>\n \n<p>\n\tThis page has been open for\n\t{$elapsed}\n\t{$elapsed === 1 ? 'second' : 'seconds'}\n</p>\n \ninitialising"
  },
  {
    "title": "Loading data / Page data • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/page-data",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 3\n/\nLoading data\n/\nPage data\n\nAt its core, SvelteKit's job boils down to three things:\n\nRouting — figure out which route matches an incoming request\nLoading — get the data needed by the route\nRendering — generate some HTML (on the server) or update the DOM (in the browser)\n\nWe've seen how routing and rendering work. Let's talk about the middle part — loading.\n\nEvery page of your app can declare a load function in a +page.server.js file alongside the +page.svelte file. As the file name suggests, this module only ever runs on the server, including for client-side navigations. Let's add a src/routes/blog/+page.server.js file so that we can replace the hard-coded links in src/routes/blog/+page.svelte with actual blog post data:\n\nsrc/routes/blog/+page.server.js\nimport { posts } from './data.js';\n\nexport function load() {\n\treturn {\n\t\tsummaries: posts.map((post) => ({\n\t\t\tslug: post.slug,\n\t\t\ttitle: post.title\n\t\t}))\n\t};\n}\n\nFor the sake of the tutorial, we're importing data from src/routes/blog/data.js. In a real app, you'd be more likely to load the data from a database or a CMS, but for now we'll do it like this.\n\nWe can access this data in src/routes/blog/+page.svelte via the data prop:\n\nsrc/routes/blog/+page.svelte\n<script>\n\texport let data;\n</script>\n\n<h1>blog</h1>\n\n<ul>\n\t<li><a href=\"/blog/one\">one</a></li>\n\t<li><a href=\"/blog/two\">two</a></li>\n\t<li><a href=\"/blog/three\">three</a></li>\n\t{#each data.summaries as { slug, title }}\n\t\t<li><a href=\"/blog/{slug}\">{title}</a></li>\n\t{/each}\n</ul>\n\nNow, let's do the same for the post page:\n\nsrc/routes/blog/[slug]/+page.server.js\nimport { posts } from '../data.js';\n\nexport function load({ params }) {\n\tconst post = posts.find((post) => post.slug === params.slug);\n\n\treturn {\n\t\tpost\n\t};\n}\nsrc/routes/blog/[slug]/+page.svelte\n<script>\n\texport let data;\n</script>\n\n<h1>blog post</h1>\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\nThere's one last detail we need to take care of — the user might visit an invalid pathname like /blog/nope, in which case we'd like to respond with a 404 page:\n\nsrc/routes/blog/[slug]/+page.server.js\nimport { error } from '@sveltejs/kit';\nimport { posts } from '../data.js';\n\nexport function load({ params }) {\n\tconst post = posts.find((post) => post.slug === params.slug);\n\n\tif (!post) throw error(404);\n\n\treturn {\n\t\tpost\n\t};\n}\n\nWe'll learn more about error handling in later chapters.\n\nNext: Layout data\n\nEdit this page\nproject\nsrc\nroutes\nblog\n[slug]\n+layout.svelte\n+page.svelte\n+page.svelte\ndata.js\n+layout.svelte\n+page.svelte\napp.html\nstatic\nfavicon.png\npackage.json\nsvelte.config.js\nvite.config.js\nsolve \n1\n2\n<p>home</p>\n\n\ninitialising"
  },
  {
    "title": "Advanced routing / Param matchers • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/param-matchers",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nTutorial\nSvelte\nSvelteKit\nPart 4\n/\nAdvanced routing\n/\nParam matchers\n\nTo prevent the router from matching on invalid input, you can specify a matcher. For example, you might want a route like /colors/[value] to match hex values like /colors/ff3e00 but not named colors like /colors/octarine or any other arbitrary input.\n\nFirst, create a new file called src/params/hex.js and export a match function from it:\n\nsrc/params/hex.js\nexport function match(value) {\n\treturn /^[0-9a-f]{6}$/.test(value);\n}\n\nThen, to use the new matcher, rename src/routes/colors/[color] to src/routes/colors/[color=hex].\n\nNow, whenever someone navigates to that route, SvelteKit will verify that color is a valid hex value. If not, SvelteKit will try to match other routes, before eventually returning a 404.\n\nMatchers run both on the server and in the browser.\n\nNext: Route groups\n\nEdit this page\nproject\nsrc\nroutes\ncolors\n[color]\n+page.svelte\n+layout.svelte\n+page.svelte\napp.html\nstatic\nfavicon.png\npackage.json\nsvelte.config.js\nvite.config.js\nsolve \n1\n2\n<h1>color picker</h1>\n \ninitialising"
  },
  {
    "title": "Routing / Layouts • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/layouts",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 3\n/\nRouting\n/\nLayouts\n\nDifferent routes of your app will often share common UI. Instead of repeating it in each +page.svelte component, we can use a +layout.svelte component that applies to all routes in the same directory.\n\nIn this app we have two routes, src/routes/+page.svelte and src/routes/about/+page.svelte, that contain the same navigation UI. Let's create a new file, src/routes/+layout.svelte...\n\nsrc/routes/\n├ about/\n│ └ +page.svelte\n├ +layout.svelte\n└ +page.svelte\n\n...and move the duplicated content from the +page.svelte files into the new +layout.svelte file. The <slot /> element is where the page content will be rendered:\n\nsrc/routes/+layout.svelte\n<nav>\n\t<a href=\"/\">home</a>\n\t<a href=\"/about\">about</a>\n</nav>\n\n<slot />\n\nA +layout.svelte file applies to every child route, including the sibling +page.svelte (if it exists). You can nest layouts to arbitrary depth.\n\nNext: Route parameters\n\nEdit this page\nproject\nsrc\nroutes\nabout\n+page.svelte\n+page.svelte\napp.html\nstatic\nfavicon.png\npackage.json\nsvelte.config.js\nvite.config.js\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n⌄\n<nav>\n\t<a href=\"/\">home</a>\n\t<a href=\"/about\">about</a>\n</nav>\n\n\n<h1>home</h1>\n<p>this is the home page.</p>\n\n\ninitialising"
  },
  {
    "title": "Link options / Preloading • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/preload",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nTutorial\nSvelte\nSvelteKit\nPart 4\n/\nLink options\n/\nPreloading\n\nIn this exercise, the /slow-a and /slow-b routes both have artificial delays in their load functions, meaning it takes a long time to navigate to them.\n\nYou can't always make your data load more quickly — sometimes it's out of your control — but SvelteKit can speed up navigations by anticipating them. When an <a> element has a data-sveltekit-preload-data attribute, SvelteKit will begin the navigation as soon as the user hovers over the link (on desktop) or taps it (on mobile). Try adding it to the first link:\n\nsrc/routes/+layout.svelte\n<nav>\n\t<a href=\"/\">home</a>\n\t<a href=\"/slow-a\" data-sveltekit-preload-data>slow-a</a>\n\t<a href=\"/slow-b\">slow-b</a>\n</nav>\n\nNavigating to /slow-a will now be noticeably faster. Starting navigation on hover or tap (rather than waiting for a click event to be registered) might not sound like it makes much difference, but in practice it typically saves 200ms or more. That's enough to be the difference between sluggish and snappy.\n\nYou can put the attribute on individual links, or on any element that contains links. The default project template includes the attribute on the <body> element:\n\n<body data-sveltekit-preload-data>\n\t%sveltekit.body%\n</body>\n\nYou can customise the behaviour further by specifying one of the following values for the attribute:\n\n\"hover\" (default, falls back to \"tap\" on mobile)\n\"tap\" — only begin preloading on tap\n\"off\" — disable preloading\n\nUsing data-sveltekit-preload-data may sometimes result in false positives - i.e. loading data in anticipation of a navigation that doesn't then happen — which might be undesirable. As an alternative, data-sveltekit-preload-code allows you to preload the JavaScript needed by a given route without eagerly loading its data. This attribute can have the following values:\n\n\"eager\" — preload everything on the page following a navigation\n\"viewport\" — preload everything as it appears in the viewport\n\"hover\" (default) as above\n\"tap\" — as above\n\"off\" — as above\n\nYou can also initiate preloading programmatically with preloadCode and preloadData imported from $app/navigation:\n\nimport { preloadCode, preloadData } from '$app/navigation';\n\n// preload the code and data needed to navigate to /foo\npreloadData('/foo');\n\n// preload the code needed to navigate to /bar, but not the data\npreloadCode('/bar');\n\nNext: Reloading the page\n\nEdit this page\nproject\nsrc\nroutes\nslow-a\n+page.server.js\n+page.svelte\nslow-b\n+page.server.js\n+page.svelte\n+layout.svelte\n+page.svelte\napp.html\nstatic\nfavicon.png\npackage.json\nsvelte.config.js\nvite.config.js\nsolve \n1\n<h1>home</h1>\ninitialising"
  },
  {
    "title": "Miscellaneous / The @debug tag • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/debug",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 2\n/\nMiscellaneous\n/\nThe @debug tag\n\nOccasionally, it's useful to inspect a piece of data as it flows through your app.\n\nOne approach is to use console.log(...) inside your markup. If you want to pause execution, though, you can use the {@debug ...} tag with a comma-separated list of values you want to inspect:\n\nApp.svelte\n{@debug user}\n\n<h1>Hello {user.firstname}!</h1>\n\nIf you now open your devtools and start interacting with the <input> elements, you'll trigger the debugger as the value of user changes. (Note that the call stack and local variables will be hidden in this tutorial, because of iframe security restrictions.)\n\nNext: Next steps\n\nEdit this page\nsrc\nApp.svelte\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n⌄\n⌄\n⌄\n⌄\n<script>\n\tlet user = {\n\t\tfirstname: 'Ada',\n\t\tlastname: 'Lovelace'\n\t};\n</script>\n\n\n<label>\n\t<input bind:value={user.firstname} />\n\tfirst name\n</label>\n\n\n<label>\n\t<input bind:value={user.lastname} />\n\tlast name\n</label>\n\n\n{(console.log(user), '')}\n\n\n<h1>Hello {user.firstname}!</h1>\n\n\ninitialising"
  },
  {
    "title": "Transitions / The transition directive • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/transition",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 2\n/\nTransitions\n/\nThe transition directive\n\nWe can make more appealing user interfaces by gracefully transitioning elements into and out of the DOM. Svelte makes this very easy with the transition directive.\n\nFirst, import the fade function from svelte/transition...\n\nApp.svelte\n<script>\n\timport { fade } from 'svelte/transition';\n\tlet visible = true;\n</script>\n\n...then add it to the <p> element:\n\nApp.svelte\n<p transition:fade>\n\tFades in and out\n</p>\n\nNext: Adding parameters\n\nEdit this page\nsrc\nApp.svelte\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n⌄\n⌄\n⌄\n⌄\n<script>\n\tlet visible = true;\n</script>\n\n\n<label>\n\t<input type=\"checkbox\" bind:checked={visible} />\n\tvisible\n</label>\n\n\n{#if visible}\n\t<p>\n\t\tFades in and out\n\t</p>\n{/if}\n\n\ninitialising"
  },
  {
    "title": "Introduction / Styling • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/styling",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 1\n/\nIntroduction\n/\nStyling\n\nJust like in HTML, you can add a <style> tag to your component. Let's add some styles to the <p> element:\n\nApp.svelte\n<p>This is a paragraph.</p>\n\n<style>\n\tp {\n\t\tcolor: goldenrod;\n\t\tfont-family: 'Comic Sans MS', cursive;\n\t\tfont-size: 2em;\n\t}\n</style>\n\nImportantly, these rules are scoped to the component. You won't accidentally change the style of <p> elements elsewhere in your app, as we'll see in the next step.\n\nNext: Nested components\n\nEdit this page\nsrc\nApp.svelte\nsolve \n1\n2\n3\n4\n5\n6\n⌄\n<p>This is a paragraph.</p>\n\n\n<style>\n\t/* Write your CSS here */\n</style>\n\n\ninitialising"
  },
  {
    "title": "Stores / Custom stores • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/custom-stores",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nTutorial\nSvelte\nSvelteKit\nPart 1\n/\nStores\n/\nCustom stores\n\nAs long as an object correctly implements the subscribe method, it's a store. Beyond that, anything goes. It's very easy, therefore, to create custom stores with domain-specific logic.\n\nFor example, the count store from our earlier example could include increment, decrement and reset methods and avoid exposing set and update:\n\nstores.js\nfunction createCount() {\n\tconst { subscribe, set, update } = writable(0);\n\n\treturn {\n\t\tsubscribe,\n\t\tincrement: () => update((n) => n + 1),\n\t\tdecrement: () => update((n) => n - 1),\n\t\treset: () => set(0)\n\t};\n}\n\nNext: Store bindings\n\nEdit this page\nsrc\nApp.svelte\nstores.js\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n<script>\n\timport { count } from './stores.js';\n</script>\n \n<h1>The count is {$count}</h1>\n \n<button on:click={count.increment}>+</button>\n<button on:click={count.decrement}>-</button>\n<button on:click={count.reset}>reset</button>\n \ninitialising"
  },
  {
    "title": "Advanced routing / Rest parameters • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/rest-params",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 4\n/\nAdvanced routing\n/\nRest parameters\n\nTo match an unknown number of path segments, use a [...rest] parameter, so named for its resemblance to rest parameters in JavaScript.\n\nRename src/routes/[path] to src/routes/[...path]. The route now matches any path.\n\nOther, more specific routes will be tested first, making rest parameters useful as 'catch-all' routes. For example, if you needed a custom 404 page for pages inside /categories/..., you could add these files:\n\nsrc/routes/\n├ categories/\n│ ├ animal/\n│ ├ mineral/\n│ ├ vegetable/\n│ ├ [...catchall]/\n│ │ ├ +error.svelte\n│ │ └ +page.server.js\n\n\nInside the +page.server.js file, throw error(404) inside load.\n\nRest parameters do not need to go at the end — a route like /items/[...path]/edit or /items/[...path].json is totally valid.\n\nNext: Param matchers\n\nEdit this page\nproject\nsrc\nroutes\n[path]\n+page.svelte\napp.html\nstatic\nfavicon.png\npackage.json\nsvelte.config.js\nvite.config.js\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n<script>\n\timport { page } from '$app/stores';\n\n\n\tlet words = ['how', 'deep', 'does', 'the', 'rabbit', 'hole', 'go'];\n\n\n\t$: depth = $page.params.path.split('/').filter(Boolean).length;\n\t$: next = depth === words.length ? '/' : `/${words.slice(0, depth + 1).join('/')}`;\n</script>\n\n\n<div class=\"flex\">\n\t{#each words.slice(0, depth) as word}\n\t\t<p>{word}</p>\n\t{/each}\n\n\n\t<p><a href={next}>{words[depth] ?? '?'}</a></p>\n</div>\n\n\n<style>\n\t.flex {\n\t\tdisplay: flex;\n\t\theight: 100%;\n\t\tflex-direction: column;\n\t\talign-items: center;\n\t\tjustify-content: center;\n\t}\n\n\n\tp {\n\t\tmargin: 0.5rem 0;\n\t\tline-height: 1;\n\t}\n\n\n\ta {\n\t\tdisplay: flex;\n\t\twidth: 100%;\n\t\theight: 100%;\n\t\talign-items: center;\ninitialising"
  },
  {
    "title": "Routing / Route parameters • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/params",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nTutorial\nSvelte\nSvelteKit\nPart 3\n/\nRouting\n/\nRoute parameters\n\nTo create routes with dynamic parameters, use square brackets around a valid variable name. For example, a file like src/routes/blog/[slug]/+page.svelte will create a route that matches /blog/one, /blog/two, /blog/three and so on.\n\nLet's create that file:\n\nsrc/routes/blog/[slug]/+page.svelte\n<h1>blog post</h1>\n\nWe can now navigate from the /blog page to individual blog posts. In the next chapter, we'll see how to load their content.\n\nMultiple route parameters can appear within one URL segment, as long as they are separated by at least one static character: foo/[bar]x[baz] is a valid route where [bar] and [baz] are dynamic parameters.\n\nNext: Loading data\n\nEdit this page\nproject\nsrc\nroutes\nblog\n+page.svelte\n+layout.svelte\n+page.svelte\napp.html\nstatic\nfavicon.png\npackage.json\nsvelte.config.js\nvite.config.js\nsolve \n1\n2\n<p>home</p>\n \ninitialising"
  },
  {
    "title": "Link options / Reloading the page • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/reload",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 4\n/\nLink options\n/\nReloading the page\n\nOrdinarily, SvelteKit will navigate between pages without refreshing the page. In this exercise, if we navigate between / and /about, the timer keeps on ticking.\n\nIn rare cases, you might want to disable this behaviour. You can do so by adding the data-sveltekit-reload attribute on an individual link, or any element that contains links:\n\nsrc/routes/+layout.svelte\n<nav data-sveltekit-reload>\n\t<a href=\"/\">home</a>\n\t<a href=\"/about\">about</a>\n</nav>\n\nFor more information on available link options and their values, consult the link options documentation.\n\nNext: Advanced routing\n\nEdit this page\nproject\nsrc\nroutes\nabout\n+page.svelte\n+layout.svelte\n+page.svelte\napp.html\nstatic\nfavicon.png\npackage.json\nsvelte.config.js\nvite.config.js\nsolve \n1\n2\n3\n<h1>home</h1>\n<p>this is the home page.</p>\n\n\ninitialising"
  },
  {
    "title": "Routing / Pages • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/pages",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nTutorial\nSvelte\nSvelteKit\nPart 3\n/\nRouting\n/\nPages\n\nSvelteKit uses filesystem-based routing, which means that the routes of your app — in other words, what the app should do when a user navigates to a particular URL — are defined by the directories in your codebase.\n\nEvery +page.svelte file inside src/routes creates a page in your app. In this app we currently have one page — src/routes/+page.svelte, which maps to /. If we navigate to /about, we'll see a 404 Not Found error.\n\nLet's fix that. Add a second page, src/routes/about/+page.svelte, copy the contents of src/routes/+page.svelte, and update it:\n\nsrc/routes/about/+page.svelte\n<nav>\n\t<a href=\"/\">home</a>\n\t<a href=\"/about\">about</a>\n</nav>\n\n<h1>about</h1>\n<p>this is the about page.</p>\n\nWe can now navigate between / and /about.\n\nUnlike traditional multi-page apps, navigating to /about and back updates the contents of the current page, like a single-page app. This gives us the best of both worlds — fast server-rendered startup, then instant navigation. (This behaviour can be configured.)\n\nNext: Layouts\n\nEdit this page\nproject\nsrc\nroutes\n+page.svelte\napp.html\nstatic\nfavicon.png\npackage.json\nsvelte.config.js\nvite.config.js\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n<nav>\n\t<a href=\"/\">home</a>\n\t<a href=\"/about\">about</a>\n</nav>\n \n<h1>home</h1>\n<p>this is the home page.</p>\n \ninitialising"
  },
  {
    "title": "Motion / Springs • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/springs",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 2\n/\nMotion\n/\nSprings\n\nThe spring function is an alternative to tweened that often works better for values that are frequently changing.\n\nIn this example we have two stores — one representing the circle's coordinates, and one representing its size. Let's convert them to springs:\n\nApp.svelte\n<script>\n\timport { spring } from 'svelte/motion';\n\n\tlet coords = spring({ x: 50, y: 50 });\n\tlet size = spring(10);\n</script>\n\nBoth springs have default stiffness and damping values, which control the spring's, well... springiness. We can specify our own initial values:\n\nApp.svelte\nlet coords = spring({ x: 50, y: 50 }, {\n\tstiffness: 0.1,\n\tdamping: 0.25\n});\n\nWaggle your mouse around, and try dragging the sliders to get a feel for how they affect the spring's behaviour. Notice that you can adjust the values while the spring is still in motion.\n\nNext: Transitions\n\nEdit this page\nsrc\nApp.svelte\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n⌄\n⌄\n⌄\n⌄\n⌄\n<script>\n\timport { writable } from 'svelte/store';\n\n\n\tlet coords = writable({ x: 50, y: 50 });\n\tlet size = writable(10);\n</script>\n\n\n<svg\n\ton:mousemove={(e) => {\n\t\tcoords.set({ x: e.clientX, y: e.clientY });\n\t}}\n\ton:mousedown={() => size.set(30)}\n\ton:mouseup={() => size.set(10)}\n\trole=\"presentation\"\n>\n\t<circle\n\t\tcx={$coords.x}\n\t\tcy={$coords.y}\n\t\tr={$size}\n\t/>\n</svg>\n\n\n<div class=\"controls\">\n\t<label>\n\t\t<h3>stiffness ({coords.stiffness})</h3>\n\t\t<input\n\t\t\tbind:value={coords.stiffness}\n\t\t\ttype=\"range\"\n\t\t\tmin=\"0.01\"\n\t\t\tmax=\"1\"\n\t\t\tstep=\"0.01\"\n\t\t/>\n\t</label>\n\n\n\t<label>\n\t\t<h3>damping ({coords.damping})</h3>\ninitialising"
  },
  {
    "title": "Next steps / Congratulations! • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/congratulations",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nTutorial\nSvelte\nSvelteKit\nPart 2\n/\nNext steps\n/\nCongratulations!\n\nYou've now finished the Svelte tutorial and are ready to start building.\n\nThe next two parts of the tutorial will focus on SvelteKit, a full-fledged framework for creating apps of all shapes and sizes.\n\nIf you're suffering from information overload and aren't ready to go through the SvelteKit tutorial yet, don't worry! You can use your existing Svelte knowledge without learning all of SvelteKit. Just run this in your terminal and follow the prompts...\n\nnpm create svelte@latest\n\n...and start editing src/routes/+page.svelte. When you're ready, click the link below to continue your journey.\n\nNext: Basic SvelteKit\n\nEdit this page\nsrc\nApp.svelte\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n<script>\n\timport { onMount } from 'svelte';\n \n\tlet characters = ['🥳', '🎉', '✨'];\n \n\tlet confetti = new Array(100)\n\t\t.fill()\n\t\t.map((_, i) => {\n\t\t\treturn {\n\t\t\t\tcharacter:\n\t\t\t\t\tcharacters[i % characters.length],\n\t\t\t\tx: Math.random() * 100,\n\t\t\t\ty: -20 - Math.random() * 100,\n\t\t\t\tr: 0.1 + Math.random() * 1\n\t\t\t};\n\t\t})\n\t\t.sort((a, b) => a.r - b.r);\n \n\tonMount(() => {\n\t\tlet frame;\n \n\t\tfunction loop() {\n\t\t\tframe = requestAnimationFrame(loop);\n \n\t\t\tconfetti = confetti.map((emoji) => {\n\t\t\t\temoji.y += 0.3 * emoji.r;\n\t\t\t\tif (emoji.y > 120) emoji.y = -20;\n\t\t\t\treturn emoji;\n\t\t\t});\n\t\t}\n \n\t\tloop();\n \n\t\treturn () => cancelAnimationFrame(frame);\n\t});\n</script>\n \n{#each confetti as c}\n\t<span\n\t\tstyle=\"left: {c.x}%; top: {c.y}%; transform: scale({c.r})\"\n\t\t>{c.character}</span\n\t>\n{/each}\n \n<style>\n\t:global(body) {\n\t\toverflow: hidden;\n\t}\n \n\tspan {\n\t\tposition: absolute;\n\t\tfont-size: 5vw;\n\t\tuser-select: none;\n\t}\n</style>\n \ninitialising"
  },
  {
    "title": "Stores / Store bindings • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/store-bindings",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 1\n/\nStores\n/\nStore bindings\n\nIf a store is writable — i.e. it has a set method — you can bind to its value, just as you can bind to local component state.\n\nIn this example we're exporting a writable store name and a derived store greeting from stores.js. Update the <input> element in App.svelte:\n\nApp.svelte\n<input bind:value={$name}>\n\nChanging the input value will now update name and all its dependents.\n\nWe can also assign directly to store values inside a component. Add an on:click event handler to update name:\n\nApp.svelte\n<button on:click={() => $name += '!'}>\n\tAdd exclamation mark!\n</button>\n\nThe $name += '!' assignment is equivalent to name.set($name + '!').\n\nNext: Advanced Svelte\n\nEdit this page\nsrc\nApp.svelte\nstores.js\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n⌄\n⌄\n<script>\n\timport { name, greeting } from './stores.js';\n</script>\n\n\n<h1>{$greeting}</h1>\n<input value={$name} />\n\n\n<button>\n\tAdd exclamation mark!\n</button>\ninitialising"
  },
  {
    "title": "Introduction / Dynamic attributes • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/dynamic-attributes",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 1\n/\nIntroduction\n/\nDynamic attributes\n\nJust like you can use curly braces to control text, you can use them to control element attributes.\n\nOur image is missing a src — let's add one:\n\nApp.svelte\n<img src={src} />\n\nThat's better. But if you hover over the <img> in the editor, Svelte is giving us a warning:\n\nA11y: <img> element should have an alt attribute\n\nWhen building web apps, it's important to make sure that they're accessible to the broadest possible userbase, including people with (for example) impaired vision or motion, or people without powerful hardware or good internet connections. Accessibility (shortened to a11y) isn't always easy to get right, but Svelte will help by warning you if you write inaccessible markup.\n\nIn this case, we're missing the alt attribute that describes the image for people using screenreaders, or people with slow or flaky internet connections that can't download the image. Let's add one:\n\nApp.svelte\n<img src={src} alt=\"A man dances.\" />\n\nWe can use curly braces inside attributes. Try changing it to \"{name} dances.\" — remember to declare a name variable in the <script> block.\n\nShorthand attributes\n\nIt's not uncommon to have an attribute where the name and value are the same, like src={src}. Svelte gives us a convenient shorthand for these cases:\n\nApp.svelte\n<img {src} alt=\"{name} dances.\" />\n\nNext: Styling\n\nEdit this page\nsrc\nApp.svelte\nsolve \n1\n2\n3\n4\n5\n6\n⌄\n<script>\n\tlet src = '/image.gif';\n</script>\n\n\n<img />\n\n\ninitialising"
  },
  {
    "title": "Advanced routing / Optional parameters • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/optional-params",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 4\n/\nAdvanced routing\n/\nOptional parameters\n\nIn the first chapter on routing, we learned how to create routes with dynamic parameters.\n\nSometimes it's helpful to make a parameter optional. A classic example is when you use the pathname to determine the locale — /fr/..., /de/... and so on — but you also want to have a default locale.\n\nTo do that, we use double brackets. Rename the [lang] directory to [[lang]].\n\nThe app now fails to build, because src/routes/+page.svelte and src/routes/[[lang]]/+page.svelte would both match /. Delete src/routes/+page.svelte. (You may need to reload the app to recover from the error page).\n\nLastly, edit src/routes/[[lang]]/+page.server.js to specify the default locale:\n\nsrc/routes/[[lang]]/+page.server.js\nconst greetings = {\n\ten: 'hello!',\n\tde: 'hallo!',\n\tfr: 'bonjour!'\n};\n\nexport function load({ params }) {\n\treturn {\n\t\tgreeting: greetings[params.lang ?? 'en']\n\t};\n}\n\nNext: Rest parameters\n\nEdit this page\nproject\nsrc\nroutes\n[lang]\n+page.server.js\n+page.svelte\n+layout.svelte\n+page.svelte\napp.html\nstatic\nfavicon.png\npackage.json\nsvelte.config.js\nvite.config.js\nsolve \n1\n2\n<h1>hello!</h1>\n\n\nbooting webcontainer"
  },
  {
    "title": "Introduction / What is SvelteKit? • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/introducing-sveltekit",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 3\n/\nIntroduction\n/\nWhat is SvelteKit?\n\nWhereas Svelte is a component framework, SvelteKit is an app framework (or 'metaframework', depending on who you ask) that solves the tricky problems of building something production-ready:\n\nRouting\nServer-side rendering\nData fetching\nService workers\nTypeScript integration\nPrerendering\nSingle-page apps\nLibrary packaging\nOptimised production builds\nDeploying to different hosting providers\n...and so on\n\nSvelteKit apps are server-rendered by default (like traditional 'multi-page apps' or MPAs) for excellent first load performance and SEO characteristics, but can then transition to client-side navigation (like modern 'single-page apps' or SPAs) to avoid jankily reloading everything (including things like third-party analytics code) when the user navigates. They can run anywhere JavaScript runs, though — as we'll see — your users may not need to run any JavaScript at all.\n\nIf that sounds complicated, worry not: SvelteKit is the framework that grows with you! Start simple and add new features as you need them.\n\nProject structure\n\nOn the right, in the file tree viewer, you'll see a handful of files that SvelteKit expects to find in a project.\n\npackage.json will be familiar if you've worked with Node.js before. It lists the project's dependencies — including svelte and @sveltejs/kit — and a variety of scripts for interacting with the SvelteKit CLI. (We're currently running npm run dev in the bottom window.)\n\nNote that it also specifies \"type\": \"module\", which means that .js files are treated as native JavaScript modules by default, rather than the legacy CommonJS format.\n\nsvelte.config.js contains your project configuration. We don't need to worry about this file for now, but if you're curious, visit the documentation.\n\nvite.config.js contains the Vite configuration. Because SvelteKit uses Vite, you can use Vite features like hot module replacement, TypeScript support, static asset handling and so on.\n\nsrc is where your app's source code goes. src/app.html is your page template (SvelteKit replaces the %sveltekit.head% and %sveltekit.body% as appropriate), and src/routes defines the routes of your app.\n\nFinally, static contains any assets (like a favicon.png or a robots.txt) that should be included when your app is deployed.\n\nNext: Routing\n\nEdit this page\nproject\nsrc\nroutes\n+page.svelte\napp.html\nstatic\nfavicon.png\npackage.json\nsvelte.config.js\nvite.config.js\nsolve \n1\n2\n<h1>Welcome to SvelteKit</h1>\n\n\ninitialising"
  },
  {
    "title": "Motion / Tweens • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/tweens",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 2\n/\nMotion\n/\nTweens\n\nNow that we've covered the basics, it's time to learn some advanced Svelte techniques, starting with motion.\n\nSetting values and watching the DOM update automatically is cool. Know what's even cooler? Tweening those values. Svelte includes tools to help you build slick user interfaces that use animation to communicate changes.\n\nLet's start by changing the progress store to a tweened store:\n\nApp.svelte\n<script>\n\timport { tweened } from 'svelte/motion';\n\n\tconst progress = tweened(0);\n</script>\n\nClicking the buttons causes the progress bar to animate to its new value. It's a bit robotic and unsatisfying though. We need to add an easing function:\n\nApp.svelte\n<script>\n\timport { tweened } from 'svelte/motion';\n\timport { cubicOut } from 'svelte/easing';\n\n\tconst progress = tweened(0, {\n\t\tduration: 400,\n\t\teasing: cubicOut\n\t});\n</script>\n\nThe svelte/easing module contains the Penner easing equations, or you can supply your own p => t function where p and t are both values between 0 and 1.\n\nThe full set of options available to tweened:\n\ndelay — milliseconds before the tween starts\nduration — either the duration of the tween in milliseconds, or a (from, to) => milliseconds function allowing you to (e.g.) specify longer tweens for larger changes in value\neasing — a p => t function\ninterpolate — a custom (from, to) => t => value function for interpolating between arbitrary values. By default, Svelte will interpolate between numbers, dates, and identically-shaped arrays and objects (as long as they only contain numbers and dates or other valid arrays and objects). If you want to interpolate (for example) colour strings or transformation matrices, supply a custom interpolator\n\nYou can also pass these options to progress.set and progress.update as a second argument, in which case they will override the defaults. The set and update methods both return a promise that resolves when the tween completes.\n\nNext: Springs\n\nEdit this page\nsrc\nApp.svelte\nsolve \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n⌄\n<script>\n\timport { writable } from 'svelte/store';\n\n\n\tconst progress = writable(0);\n</script>\n\n\n<progress value={$progress} />\n\n\n<button on:click={() => progress.set(0)}>\n\t0%\n</button>\n\n\n<button on:click={() => progress.set(0.25)}>\n\t25%\n</button>\n\n\n<button on:click={() => progress.set(0.5)}>\n\t50%\n</button>\n\n\n<button on:click={() => progress.set(0.75)}>\n\t75%\n</button>\n\n\n<button on:click={() => progress.set(1)}>\n\t100%\n</button>\n\n\n<style>\n\tprogress {\n\t\tdisplay: block;\n\t\twidth: 100%;\n\t}\n</style>\n\n\ninitialising"
  },
  {
    "title": "Introduction / Your first component • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/your-first-component",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 1\n/\nIntroduction\n/\nYour first component\n\nIn Svelte, an application is composed from one or more components. A component is a reusable self-contained block of code that encapsulates HTML, CSS and JavaScript that belong together, written into a .svelte file. The App.svelte file, open in the code editor to the right, is a simple component.\n\nAdding data\n\nA component that just renders some static markup isn't very interesting. Let's add some data.\n\nFirst, add a script tag to your component and declare a name variable:\n\nApp.svelte\n<script>\n\tlet name = 'Svelte';\n</script>\n\n<h1>Hello world!</h1>\n\nThen, we can refer to name in the markup:\n\nApp.svelte\n<h1>Hello {name}!</h1>\n\nInside the curly braces, we can put any JavaScript we want. Try changing name to name.toUpperCase() for a shoutier greeting.\n\nApp.svelte\n<h1>Hello {name.toUpperCase()}!</h1>\n\nNext: Dynamic attributes\n\nEdit this page\nsrc\nApp.svelte\nsolve \n1\n2\n<h1>Hello world!</h1>\n\n\nbooting webcontainer"
  },
  {
    "title": "Introduction / Welcome to Svelte • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/welcome-to-svelte",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nTutorial\nSvelte\nSvelteKit\nPart 1\n/\nIntroduction\n/\nWelcome to Svelte\n\nWelcome to the Svelte tutorial! This will teach you everything you need to know to easily build web applications of all sizes, with high performance and a small footprint.\n\nYou can also consult the API docs and the examples, or — if you're impatient to start hacking on your machine locally — create a project with npm init svelte.\n\nWhat is Svelte?\n\nSvelte is a tool for building web applications. Like other user interface frameworks, it allows you to build your app declaratively out of components that combine markup, styles and behaviours.\n\nThese components are compiled into small, efficient JavaScript modules that eliminate overhead traditionally associated with UI frameworks.\n\nYou can build your entire app with Svelte (for example, using an application framework like SvelteKit, which this tutorial will cover), or you can add it incrementally to an existing codebase. You can also ship components as standalone packages that work anywhere.\n\nHow to use this tutorial\n\nYou'll need to have basic familiarity with HTML, CSS and JavaScript to understand Svelte.\n\nThis tutorial is split into four main parts:\n\nBasic Svelte (you are here)\nAdvanced Svelte\nBasic SvelteKit\nAdvanced SvelteKit\n\nEach section will present an exercise designed to illustrate a feature. Later exercises build on the knowledge gained in earlier ones, so it's recommended that you go from start to finish. If necessary, you can navigate via the menu above.\n\nIf you get stuck, you can click the solve button to the left of the editor. (The solve button is disabled on sections like this one that don't include an exercise.) Try not to rely on it too much; you will learn faster by figuring out where to put each suggested code block and manually typing it in to the editor.\n\nNext: Your first component\n\nEdit this page\nsrc\nApp.svelte\nsolve \n1\n2\n<h1>Welcome!</h1>\n \ninitialising"
  },
  {
    "title": "Introduction / Welcome to Svelte • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/welcome-to-svelte#main",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nTutorial\nSvelte\nSvelteKit\nPart 1\n/\nIntroduction\n/\nWelcome to Svelte\n\nWelcome to the Svelte tutorial! This will teach you everything you need to know to easily build web applications of all sizes, with high performance and a small footprint.\n\nYou can also consult the API docs and the examples, or — if you're impatient to start hacking on your machine locally — create a project with npm init svelte.\n\nWhat is Svelte?\n\nSvelte is a tool for building web applications. Like other user interface frameworks, it allows you to build your app declaratively out of components that combine markup, styles and behaviours.\n\nThese components are compiled into small, efficient JavaScript modules that eliminate overhead traditionally associated with UI frameworks.\n\nYou can build your entire app with Svelte (for example, using an application framework like SvelteKit, which this tutorial will cover), or you can add it incrementally to an existing codebase. You can also ship components as standalone packages that work anywhere.\n\nHow to use this tutorial\n\nYou'll need to have basic familiarity with HTML, CSS and JavaScript to understand Svelte.\n\nThis tutorial is split into four main parts:\n\nBasic Svelte (you are here)\nAdvanced Svelte\nBasic SvelteKit\nAdvanced SvelteKit\n\nEach section will present an exercise designed to illustrate a feature. Later exercises build on the knowledge gained in earlier ones, so it's recommended that you go from start to finish. If necessary, you can navigate via the menu above.\n\nIf you get stuck, you can click the solve button to the left of the editor. (The solve button is disabled on sections like this one that don't include an exercise.) Try not to rely on it too much; you will learn faster by figuring out where to put each suggested code block and manually typing it in to the editor.\n\nNext: Your first component\n\nEdit this page\nsrc\nApp.svelte\nsolve \n1\n2\n<h1>Welcome!</h1>\n \ninitialising"
  },
  {
    "title": "Introduction / Welcome to Svelte • Svelte Tutorial",
    "url": "https://learn.svelte.dev/tutorial/welcome-to-svelte",
    "html": "Skip to main content\nLEARN.SVELTE.DEV\nCTRL K\nTutorial\nSvelte\nSvelteKit\nPart 1\n/\nIntroduction\n/\nWelcome to Svelte\n\nWelcome to the Svelte tutorial! This will teach you everything you need to know to easily build web applications of all sizes, with high performance and a small footprint.\n\nYou can also consult the API docs and the examples, or — if you're impatient to start hacking on your machine locally — create a project with npm init svelte.\n\nWhat is Svelte?\n\nSvelte is a tool for building web applications. Like other user interface frameworks, it allows you to build your app declaratively out of components that combine markup, styles and behaviours.\n\nThese components are compiled into small, efficient JavaScript modules that eliminate overhead traditionally associated with UI frameworks.\n\nYou can build your entire app with Svelte (for example, using an application framework like SvelteKit, which this tutorial will cover), or you can add it incrementally to an existing codebase. You can also ship components as standalone packages that work anywhere.\n\nHow to use this tutorial\n\nYou'll need to have basic familiarity with HTML, CSS and JavaScript to understand Svelte.\n\nThis tutorial is split into four main parts:\n\nBasic Svelte (you are here)\nAdvanced Svelte\nBasic SvelteKit\nAdvanced SvelteKit\n\nEach section will present an exercise designed to illustrate a feature. Later exercises build on the knowledge gained in earlier ones, so it's recommended that you go from start to finish. If necessary, you can navigate via the menu above.\n\nIf you get stuck, you can click the solve button to the left of the editor. (The solve button is disabled on sections like this one that don't include an exercise.) Try not to rely on it too much; you will learn faster by figuring out where to put each suggested code block and manually typing it in to the editor.\n\nNext: Your first component\n\nEdit this page\nsrc\nApp.svelte\nsolve \n1\n2\n<h1>Welcome!</h1>\n\n\nbooting webcontainer"
  }
]